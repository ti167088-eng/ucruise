<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RouteFlow - Smart Driver Assignment Platform</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        :root {
            /* Dark Theme Color Palette */
            --primary-500: #242425;
            --primary-600: #565657;
            --primary-700: #8e8ca5;
            --primary-50: #1e1b4b;
            --primary-100: #0b0b0f;

            --success-500: #10b981;
            --success-100: #064e3b;
            --warning-500: #f59e0b;
            --warning-100: #451a03;
            --error-500: #ef4444;
            --error-100: #450a0a;

            --gray-50: #0f172a;
            --gray-100: #1e293b;
            --gray-200: #334155;
            --gray-300: #475569;
            --gray-400: #64748b;
            --gray-500: #94a3b8;
            --gray-600: #cbd5e1;
            --gray-700: #e6eefb;
            --gray-800: #f1f5f9;
            --gray-900: #f8fafc;

            --surface-white: #0f172a;
            --surface-gray: #1e293b;

            /* Enhanced Shadows for Dark Theme */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.4), 0 2px 4px -2px rgb(0 0 0 / 0.4);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.4), 0 4px 6px -4px rgb(0 0 0 / 0.4);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.5), 0 8px 10px -6px rgb(0 0 0 / 0.5);

            /* Radius */
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;

            /* Spacing */
            --space-xs: 0.5rem;
            --space-sm: 0.75rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 2.5rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Make the map fill the viewport and sit under UI */
        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(180deg, #071029 0%, #0f172a 100%);
            color: var(--gray-700);
            font-size: 14px;
            line-height: 1.5;
        }

        /* ===== Glassmorphism overlay layout ===== */
        
        /* App overlay sits above the map - no grid, just overlay */
        .app-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Allow map to be interactive */
        #map {
            pointer-events: auto;
        }

        /* Sidebar becomes a floating glass card - positioned absolutely */
        .sidebar {
            pointer-events: auto;
            position: fixed;
            top: 20px;
            left: 20px;
            width: 360px;
            max-height: calc(100vh - 40px);
            height: auto;
            background: rgba(15, 23, 42, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px;
            padding: 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset,
                        0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
        }

        /* When collapsed, shrink to a pill on the left */
        .app-container.sidebar-collapsed .sidebar {
            width: 78px;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 4px;
            height: 100%;
            cursor: ew-resize;
            background: transparent;
            z-index: 1001;
            transition: background 0.2s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.resizing {
            background: var(--primary-500);
        }

        .sidebar-collapse-btn {
            position: absolute;
            top: 20px;
            right: 12px;
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.2s;
        }

        .sidebar-collapse-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .sidebar-collapsed .sidebar-content,
        .sidebar-collapsed .sidebar-header .logo h1,
        .sidebar-collapsed .sidebar-header .tagline {
            display: none;
        }

        .sidebar-collapsed .sidebar-header {
            padding: var(--space-md);
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-collapsed .logo {
            margin-bottom: 0;
        }

        .sidebar-collapsed .logo i {
            font-size: 28px;
        }

        .sidebar-collapsed .cluster-palette {
            flex-direction: column;
            align-items: center;
            padding: var(--space-sm);
        }

        .sidebar-collapsed .floating-legend {
            left: 80px;
        }

        .sidebar-collapsed .sidebar-collapse-btn {
            right: 14px;
        }

        .sidebar-header {
            padding: var(--space-xl);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(79, 70, 229, 0.4));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-xs);
        }

        .logo i {
            font-size: 24px;
        }

        .logo h1 {
            font-size: 24px;
            font-weight: 800;
            letter-spacing: -0.025em;
        }

        .tagline {
            font-size: 13px;
            opacity: 0.9;
            font-weight: 400;
        }

        .sidebar-content {
            flex: 1;
            padding: var(--space-lg);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .sidebar-content::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar-content::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 4px;
        }

        .sidebar-content::-webkit-scrollbar-thumb {
            background: rgba(99, 102, 241, 0.5);
            border-radius: 4px;
        }

        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: rgba(99, 102, 241, 0.7);
        }

        .section {
            margin-bottom: var(--space-xl);
        }

        .section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--gray-700);
            margin-bottom: var(--space-md);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .section-title i {
            font-size: 14px;
            color: var(--primary-500);
        }

        /* Form Controls */
        .form-group {
            margin-bottom: var(--space-md);
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--gray-700);
            margin-bottom: var(--space-xs);
        }

        .form-input {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            border: 1.5px solid var(--gray-200);
            border-radius: var(--radius-md);
            font-size: 13px;
            transition: all 0.2s ease;
            background: var(--surface-gray);
            color: var(--gray-800);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-500);
            box-shadow: 0 0 0 3px var(--primary-100);
        }

        .form-select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2394a3b8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right var(--space-sm) center;
            background-repeat: no-repeat;
            background-size: 16px 12px;
            padding-right: var(--space-2xl);
        }

        .range-input {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--gray-200);
            outline: none;
            appearance: none;
        }

        .range-input::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-500);
            cursor: pointer;
            box-shadow: var(--shadow-md);
        }

        /* Buttons - Glassmorphism Style */
        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            width: 100%;
            margin-bottom: var(--space-xs);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(79, 70, 229, 0.3));
            color: #f1f5f9;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(79, 70, 229, 0.4));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            border-color: rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: rgba(30, 41, 59, 0.4);
            color: var(--gray-700);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .btn-secondary:hover {
            background: rgba(30, 41, 59, 0.6);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .btn-secondary.active {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.25), rgba(79, 70, 229, 0.35));
            border-color: rgba(99, 102, 241, 0.5);
            color: #f1f5f9;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-xs);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
        }

        .stat-card {
            background: rgba(15, 23, 42, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px) saturate(150%);
            -webkit-backdrop-filter: blur(12px) saturate(150%);
            padding: var(--space-lg);
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3),
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--gray-900);
            margin-bottom: var(--space-xs);
        }

        .stat-label {
            font-size: 11px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 500;
        }

        /* Analytics Cards */
        .analytics-card {
            background: rgba(15, 23, 42, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px) saturate(150%);
            -webkit-backdrop-filter: blur(12px) saturate(150%);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3),
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            overflow: hidden;
        }

        .analytics-header {
            padding: var(--space-lg);
            border-bottom: 1px solid var(--gray-200);
            background: var(--gray-100);
        }

        .analytics-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .analytics-body {
            padding: var(--space-lg);
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
            border-bottom: 1px solid var(--gray-200);
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-size: 12px;
            color: var(--gray-600);
            font-weight: 400;
        }

        .metric-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--gray-900);
        }

        /* Map Container - now just a wrapper */
        .map-container {
            position: relative;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }
        
        /* Map fills viewport and sits under UI */
        #map {
            position: fixed !important;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            border: none;
            background: linear-gradient(180deg, #071029 0%, #0f172a 100%);
        }

        /* Map header (floating over map) */
        .map-header {
            pointer-events: auto;
            position: fixed;
            top: 22px;
            left: 400px;
            right: 22px;
            height: auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 18px;
            background: rgba(15, 23, 42, 0.25);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            z-index: 90;
            transition: left 0.3s ease;
        }

        .app-container.sidebar-collapsed .map-header {
            left: 118px;
        }

        .map-header.edit-mode {
            border-top: 4px solid #ff6b35;
            border-bottom: 2px solid #ff6b35;
        }

        .map-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--gray-800);
        }

        .map-controls {
            display: flex;
            gap: var(--space-sm);
        }

        .edit-mode-indicator {
            background: #ff6b35;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: var(--space-md);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .map-btn {
            padding: var(--space-xs) var(--space-md);
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            font-size: 12px;
            font-weight: 600;
            color: var(--gray-700);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .map-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .map-btn:hover::before {
            left: 100%;
        }

        .map-btn:focus,
        .map-btn:hover {
            background: rgba(30, 41, 59, 0.7);
            border-color: rgba(99, 102, 241, 0.4);
            color: #c7d2fe;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .map-btn.active {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(79, 70, 229, 0.4));
            border-color: rgba(99, 102, 241, 0.5);
            color: #f1f5f9;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #editRoutesBtn {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.3), rgba(247, 147, 30, 0.4)) !important;
            color: white !important;
            font-weight: 700 !important;
            padding: 10px 20px !important;
            font-size: 13px !important;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 140, 97, 0.4) !important;
            backdrop-filter: blur(12px) !important;
            -webkit-backdrop-filter: blur(12px) !important;
        }

        #editRoutesBtn:hover {
            background: linear-gradient(135deg, rgba(247, 147, 30, 0.4), rgba(255, 107, 53, 0.5)) !important;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
            border-color: rgba(255, 140, 97, 0.6) !important;
        }

        #map {
            flex: 1;
            width: 100%;
            border: none;
        }

        /* Floating Elements */
        /* Floating legend as glass card (over map) */
        .floating-legend {
            position: fixed;
            bottom: 28px;
            left: 400px;
            background: rgba(15, 23, 42, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            min-width: 250px;
            z-index: 90;
            pointer-events: auto;
            transition: left 0.3s ease;
        }

        .floating-legend.hidden-in-edit {
            display: none;
        }

        .app-container.sidebar-collapsed .floating-legend {
            left: 118px;
        }

        .legend-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: var(--space-md);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            margin-bottom: var(--space-sm);
            font-size: 12px;
            color: var(--gray-600);
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-icon {
            width: 20px;
            height: 20px;
            border-radius: 6px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .route-info-popup {
            position: fixed;
            background: rgba(15, 23, 42, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            padding: 0;
            border-radius: 14px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            max-width: 280px;
            display: none;
            pointer-events: none;
            z-index: 9999;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: translateY(8px);
            overflow: hidden;
        }

        .route-info-popup.visible {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* Loading States */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--gray-200);
            border-top: 3px solid var(--primary-500);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--space-md);
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 14px;
            color: var(--gray-600);
            font-weight: 500;
        }

        /* Progress Bars */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--gray-200);
            border-radius: 4px;
            overflow: hidden;
            margin-top: var(--space-xs);
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .progress-success {
            background: var(--success-500);
        }

        .progress-warning {
            background: var(--warning-500);
        }

        .progress-error {
            background: var(--error-500);
        }

        /* Alerts */
        .alert {
            padding: var(--space-md);
            border-radius: var(--radius-md);
            font-size: 12px;
            margin-bottom: var(--space-sm);
        }

        .alert-success {
            background: var(--success-100);
            color: var(--success-500);
            border-left: 3px solid var(--success-500);
        }

        .alert-warning {
            background: var(--warning-100);
            color: var(--warning-500);
            border-left: 3px solid var(--warning-500);
        }

        .alert-error {
            background: var(--error-100);
            color: var(--error-500);
            border-left: 3px solid var(--error-500);
        }

        /* Enhanced Cluster Colors with Better Differentiation */
        .cluster-palette {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
            margin-top: var(--space-md);
        }

        .cluster-color {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 3px solid rgba(255, 255, 255, 0.4);
            box-shadow: var(--shadow-md);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 10px;
        }

        .cluster-color:hover {
            transform: scale(1.2);
            box-shadow: var(--shadow-lg);
            border-color: rgba(255, 255, 255, 0.8);
        }

        .cluster-color.active {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .cluster-color.active::after {
            content: 'âœ“';
            position: absolute;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }

        /* Marker animations */
        @keyframes markerBounce {

            0%,
            100% {
                transform: translateY(0) scale(1);
            }

            50% {
                transform: translateY(-10px) scale(1.1);
            }
        }

        @keyframes markerDrop {
            0% {
                transform: translateY(-100px);
                opacity: 0;
            }

            60% {
                transform: translateY(5px);
                opacity: 1;
            }

            80% {
                transform: translateY(-3px);
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes markerPulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(14, 165, 164, 0.7);
            }

            50% {
                box-shadow: 0 0 0 10px rgba(14, 165, 164, 0);
            }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .app-container:not(.sidebar-collapsed) {
                grid-template-columns: 320px 1fr;
            }

            .sidebar {
                font-size: 13px;
                width: 320px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .map-header {
                left: 360px;
            }
        }

        /* Responsive: mobile layout - panels stack as small glass cards */
        @media (max-width: 900px) {
            .app-container {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                position: absolute;
                left: 16px;
                top: 16px;
                width: calc(100% - 32px);
                height: auto;
                max-height: 42vh;
                margin: 0;
            }
            
            .map-header { 
                left: 16px; 
                right: 16px; 
                top: calc(16px + 42vh); /* Adjust top based on sidebar height */
            }
            
            .floating-legend {
                left: 16px;
                bottom: 16px;
            }

            .sidebar-resize-handle {
                display: none;
            }
        }

        /* Panels should scroll internally not push map layout */
        .sidebar, .route-editor-panel, .route-details-panel {
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Slight glass highlight on focus for keyboard users */
        .sidebar :focus-within,
        .route-editor-panel :focus-within {
            outline: 2px solid rgba(99,102,241,0.14);
            box-shadow: 0 10px 30px rgba(99,102,241,0.06);
        }

        /* Custom Scrollbar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--gray-100);
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--gray-300);
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--gray-400);
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .text-sm {
            font-size: 12px;
        }

        .text-xs {
            font-size: 11px;
        }

        .font-medium {
            font-weight: 500;
        }

        .font-semibold {
            font-weight: 600;
        }

        .opacity-75 {
            opacity: 0.75;
        }

        .mb-0 {
            margin-bottom: 0;
        }

        /* Mini-map thumbnails panel */
        .mini-maps-panel {
            position: absolute;
            top: 80px;
            right: var(--space-xl);
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.05);
            backdrop-filter: blur(16px) saturate(120%);
            -webkit-backdrop-filter: blur(16px) saturate(120%);
            padding: var(--space-lg);
            border-radius: 14px;
            box-shadow: 0 12px 40px rgba(2,6,23,0.6);
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            display: none;
            z-index: 999;
            width: 300px;
            pointer-events: auto;
        }

        .mini-maps-panel.active {
            display: block;
        }

        .mini-map-item {
            margin-bottom: var(--space-md);
            border: 2px solid transparent;
            border-radius: var(--radius-md);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mini-map-item:hover {
            border-color: var(--primary-500);
            transform: scale(1.02);
        }

        .mini-map-item.selected {
            border-color: var(--primary-500);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.4);
        }

        .mini-map-canvas {
            width: 100%;
            height: 120px;
            background: #1e293b;
            border-radius: var(--radius-sm);
        }

        .mini-map-info {
            padding: var(--space-sm);
            background: #1e293b;
            color: var(--gray-700);
            font-size: 12px;
        }

        /* Route Editor Panel - glassmorphism */
        .route-editor-panel {
            position: fixed;
            top: 0;
            left: -600px;
            width: 600px;
            height: 100vh;
            background: rgba(15, 23, 42, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.5),
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            border-radius: 0 14px 14px 0;
            border-right: 2px solid rgba(99, 102, 241, 0.5);
            z-index: 120;
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            pointer-events: auto;
        }

        .route-editor-panel.active {
            left: 0;
        }

        .editor-header {
            padding: var(--space-lg);
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            border-bottom: 2px solid #ff6b35;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .editor-close {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .editor-close:hover {
            background: rgba(239, 68, 68, 0.4);
            transform: rotate(90deg) scale(1.1);
            border-color: rgba(239, 68, 68, 0.6);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .editor-tabs {
            display: flex;
            background: var(--gray-100);
            border-bottom: 1px solid var(--gray-200);
        }

        .editor-tab {
            flex: 1;
            padding: var(--space-md);
            background: transparent;
            border: none;
            color: var(--gray-600);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }

        .editor-tab.active {
            color: var(--primary-500);
            background: var(--surface-gray);
            border-bottom-color: var(--primary-500);
        }

        .editor-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-lg);
        }

        .user-pool {
            background: var(--surface-gray);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .pool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .user-card-draggable {
            background: var(--gray-100);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
            cursor: move;
            transition: all 0.2s;
            border-left: 4px solid var(--primary-500);
        }

        .user-card-draggable:hover {
            background: var(--gray-200);
            transform: translateX(4px);
            box-shadow: var(--shadow-md);
        }

        .user-card-draggable.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .route-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        .route-card-editor {
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            border: 1px solid rgba(255,255,255,0.04);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(2,6,23,0.5);
            transition: all 0.2s;
        }

        .route-card-editor.drag-over {
            border-color: var(--primary-500);
            background: rgba(99, 102, 241, 0.1);
        }

        .route-card-header {
            padding: var(--space-md);
            background: var(--gray-100);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .route-card-editor.expanded .route-card-body {
            display: block;
        }

        .drop-zone {
            min-height: 60px;
            border: 2px dashed var(--gray-300);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gray-500);
            transition: all 0.2s;
            margin-top: var(--space-md);
        }

        .drop-zone.active {
            border-color: var(--primary-500);
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary-500);
        }

        /* Undo/Redo Timeline */
        .history-timeline {
            background: var(--surface-gray);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .timeline-item {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            padding: var(--space-sm);
            border-left: 3px solid var(--gray-300);
            margin-left: var(--space-md);
            position: relative;
            transition: all 0.2s;
        }

        .timeline-item:before {
            content: '';
            position: absolute;
            left: -9px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--gray-300);
        }

        .timeline-item.current {
            border-left-color: var(--primary-500);
        }

        .timeline-item.current:before {
            background: var(--primary-500);
        }

        .timeline-item:hover {
            background: var(--gray-100);
            cursor: pointer;
        }

        /* What-if Simulator */
        .simulator-panel {
            background: var(--surface-gray);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .simulator-preview {
            background: var(--gray-100);
            border-radius: var(--radius-md);
            padding: var(--space-lg);
            margin-top: var(--space-md);
        }

        .preview-animation {
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .metric-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
            margin-top: var(--space-md);
        }

        .metric-box-compare {
            background: var(--gray-100);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            text-align: center;
        }

        .metric-delta {
            font-size: 12px;
            font-weight: 600;
            margin-top: var(--space-xs);
        }

        .metric-delta.positive {
            color: var(--success-500);
        }

        .metric-delta.negative {
            color: var(--error-500);
        }

        /* Drag overlay */
        .drag-overlay {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            background: rgba(99, 102, 241, 0.9);
            color: white;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-xl);
            font-size: 13px;
            font-weight: 500;
        }

        .insertion-indicator {
            position: absolute;
            height: 3px;
            background: var(--primary-500);
            box-shadow: 0 0 10px var(--primary-500);
            pointer-events: none;
            z-index: 1000;
            transition: all 0.1s;
        }

        /* Route dimming for hover effects */
        .route-dimmed {
            opacity: 0.3 !important;
            transition: opacity 0.3s ease;
        }

        .route-highlighted {
            opacity: 1 !important;
            filter: drop-shadow(0 0 8px currentColor);
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        /* Sliding route details panel - glassmorphism matching sidebar */
        .route-details-panel {
            position: fixed;
            top: 0;
            right: -500px;
            width: 500px;
            height: 100vh;
            background: rgba(15, 23, 42, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset,
                        0 20px 60px rgba(0, 0, 0, 0.3);
            border-radius: 16px 0 0 16px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 110;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
            overflow-x: hidden;
            pointer-events: auto;
        }

        /* Compact route inspector styles */
        .route-inspector-card {
            background: transparent;
            border-radius: 0;
            border: none;
            overflow: hidden;
        }

        .inspector-header {
            padding: 10px 14px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .inspector-title {
            font-size: 12px;
            font-weight: 600;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 7px;
        }

        .inspector-badge {
            font-size: 9px;
            background: rgba(255, 255, 255, 0.12);
            padding: 2px 7px;
            border-radius: 8px;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .inspector-body {
            padding: 12px 14px;
        }

        .inspector-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .metric-compact {
            text-align: center;
            padding: 8px;
            background: rgba(30, 41, 59, 0.3);
            border-radius: 9px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
        }

        .metric-compact-value {
            font-size: 16px;
            font-weight: 700;
            color: #f1f5f9;
        }

        .metric-compact-label {
            font-size: 8px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 3px;
        }

        /* Sparkline chart styles */
        .sparkline-container {
            margin-top: 8px;
            padding: 8px;
            background: rgba(30, 41, 59, 0.25);
            border-radius: 9px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
        }

        .sparkline-label {
            font-size: 8px;
            color: #94a3b8;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .sparkline {
            width: 100%;
            height: 26px;
        }

        .capacity-bar {
            width: 100%;
            height: 5px;
            background: rgba(51, 65, 85, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        .capacity-fill {
            height: 100%;
            transition: width 0.3s ease;
            background: linear-gradient(90deg, var(--success-500), var(--primary-500));
        }

        .inspector-footer {
            padding: 8px 14px;
            background: transparent;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 8px;
            color: #94a3b8;
            text-align: center;
        }

        .route-details-panel.active {
            right: 0;
        }

        .route-details-header {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(79, 70, 229, 0.4));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: var(--space-xl);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
        }

        .route-details-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
        }

        .route-details-title h3 {
            margin: 0;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .route-details-close {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .route-details-close:hover {
            background: rgba(239, 68, 68, 0.4);
            transform: rotate(90deg) scale(1.1);
            border-color: rgba(239, 68, 68, 0.6);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .route-details-content {
            padding: var(--space-xl);
        }

        .details-section {
            background: rgba(30, 41, 59, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px) saturate(150%);
            -webkit-backdrop-filter: blur(12px) saturate(150%);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            margin-bottom: var(--space-lg);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3),
                        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
        }

        .details-section-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-500);
            margin-bottom: var(--space-md);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            padding-bottom: var(--space-sm);
            border-bottom: 2px solid var(--gray-200);
        }

        .details-grid {
            display: grid;
            gap: var(--space-sm);
        }

        .details-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xs) 0;
            font-size: 13px;
        }

        .details-label {
            color: var(--gray-500);
            font-weight: 500;
        }

        .details-value {
            color: var(--gray-800);
            font-weight: 600;
        }

        .user-card {
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            border: 1px solid rgba(255,255,255,0.04);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 12px;
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
            border-left: 3px solid var(--primary-500);
            box-shadow: 0 6px 18px rgba(2,6,23,0.5);
            transition: all 0.2s;
        }

        .user-card:hover {
            background: var(--gray-200);
            transform: translateX(4px);
        }

        .user-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-xs);
        }

        .user-card-name {
            font-weight: 600;
            color: var(--gray-800);
            font-size: 14px;
        }

        .user-card-id {
            font-size: 11px;
            color: var(--gray-500);
            background: var(--gray-200);
            padding: 2px 8px;
            border-radius: 12px;
        }

        .user-card-details {
            font-size: 12px;
            color: var(--gray-600);
            display: grid;
            gap: 4px;
        }

        .route-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .metric-box {
            background: var(--gray-100);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            text-align: center;
        }

        .metric-box-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary-500);
            margin-bottom: var(--space-xs);
        }

        .metric-box-label {
            font-size: 11px;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
    </style>
</head>

<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-text">Loading route analytics...</div>
        </div>
    </div>

    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="logo">
                    <!-- Minimal circular mark with two colorful arcs and RF monogram -->
                    <svg width="42" height="42" viewBox="0 0 42 42" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                        <defs>
                            <linearGradient id="g1" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" stop-color="#36D1DC"/>
                                <stop offset="100%" stop-color="#5B86E5"/>
                            </linearGradient>
                            <linearGradient id="g2" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" stop-color="#FFB86B"/>
                                <stop offset="100%" stop-color="#FF6B6B"/>
                            </linearGradient>
                        </defs>
                        <circle cx="21" cy="21" r="20" fill="url(#g1)" opacity="0.95"/>
                        <path d="M21 5 A16 16 0 0 1 37 21" stroke="url(#g2)" stroke-width="4" fill="none" stroke-linecap="round" />
                        <text x="50%" y="58%" font-family="Inter, Arial" font-size="14" font-weight="700" text-anchor="middle" fill="#fff">RF</text>
                    </svg>
                    <h1 style="font-size:18px; font-weight:700; margin-left:10px;">RouteFlow</h1>
                </div>
                <div class="tagline">Smart Driver Assignment Platform</div>
                <button class="sidebar-collapse-btn" onclick="toggleSidebar()" title="Collapse sidebar">
                    <i class="fas fa-chevron-left"></i>
                </button>
            </div>
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>

            <div class="sidebar-content">
                <!-- Quick Stats -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-chart-line"></i>
                        Overview
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="totalRoutes">0</div>
                            <div class="stat-label">Active Routes</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalUsers">0</div>
                            <div class="stat-label">Users Assigned</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="avgUtilization">0%</div>
                            <div class="stat-label">Avg Utilization</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="totalDrivers">0</div>
                            <div class="stat-label">Active Drivers</div>
                        </div>
                    </div>
                </div>

                <!-- Filters -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-filter"></i>
                        Filters
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="searchInput">Search Routes or Users</label>
                        <input type="text" id="searchInput" class="form-input"
                            placeholder="Enter ID, name, or keyword..." oninput="handleSearch()">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="clusterSelect">Route Selection</label>
                        <select id="clusterSelect" class="form-input form-select" onchange="filterCluster()">
                            <option value="all">All Routes</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="utilizationRange">
                            Min Utilization: <span id="utilizationValue" class="font-semibold">0%</span>
                        </label>
                        <input type="range" id="utilizationRange" class="range-input" min="0" max="100" value="0"
                            oninput="filterByUtilization()">
                    </div>
                </div>

                <!-- Display Controls -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-eye"></i>
                        Display Options
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="toggleUsers()" id="toggleUsersBtn">
                            <i class="fas fa-users"></i> Users
                        </button>
                        <button class="btn btn-secondary" onclick="toggleDrivers()" id="toggleDriversBtn">
                            <i class="fas fa-car"></i> Drivers
                        </button>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="toggleRouteLines()" id="toggleRouteLinesBtn">
                            <i class="fas fa-route"></i> Pickup Routes
                        </button>
                        <button class="btn btn-secondary" onclick="toggleHeatmap()" id="toggleHeatmapBtn">
                            <i class="fas fa-fire"></i> Heatmap
                        </button>
                    </div>
                    <button class="btn btn-secondary" onclick="toggleUserNameDisplay()" id="toggleUserNameBtn">
                        <i class="fas fa-id-badge"></i> Show User Names
                    </button>
                    <button class="btn btn-primary" onclick="showOptimalPaths()" id="showOptimalBtn">
                        <i class="fas fa-magic"></i> Show Optimal Paths
                    </button>
                </div>

                <!-- Performance Analytics -->
                <div class="section">
                    <div class="analytics-card">
                        <div class="analytics-header">
                            <div class="analytics-title">
                                <i class="fas fa-tachometer-alt"></i>
                                Performance Metrics
                            </div>
                        </div>
                        <div class="analytics-body">
                            <div class="metric-row">
                                <span class="metric-label">Assignment Rate</span>
                                <span class="metric-value" id="assignmentRate">0%</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Capacity Utilization</span>
                                <span class="metric-value" id="capacityUtilization">0%</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Avg Distance</span>
                                <span class="metric-value" id="avgDistance">0 km</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Efficiency Score</span>
                                <span class="metric-value" id="efficiencyScore">0/10</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Route Quality -->
                <div class="section">
                    <div class="analytics-card">
                        <div class="analytics-header">
                            <div class="analytics-title">
                                <i class="fas fa-award"></i>
                                Route Quality
                            </div>
                        </div>
                        <div class="analytics-body">
                            <div class="metric-row">
                                <span class="metric-label">High Efficiency (â‰¥80%)</span>
                                <span class="metric-value" id="highEfficiencyRoutes">0</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Medium Efficiency (50-79%)</span>
                                <span class="metric-value" id="mediumEfficiencyRoutes">0</span>
                            </div>
                            <div class="metric-row">
                                <span class="metric-label">Low Efficiency (<50%)< /span>
                                        <span class="metric-value" id="lowEfficiencyRoutes">0</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Efficiency Alerts -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-exclamation-triangle"></i>
                        System Alerts
                    </div>
                    <div id="alertsContainer">
                        <div class="alert alert-success">
                            <i class="fas fa-check-circle"></i> System initialized successfully
                        </div>
                    </div>
                </div>

                <!-- Export Options -->
                <div class="section">
                    <div class="section-title">
                        <i class="fas fa-download"></i>
                        Export & Reports
                    </div>
                    <button class="btn btn-primary" onclick="exportAnalytics()">
                        <i class="fas fa-file-csv"></i> Export Data
                    </button>
                    <button class="btn btn-secondary" onclick="generateReport()">
                        <i class="fas fa-file-pdf"></i> Generate Report
                    </button>
                    <button class="btn btn-secondary" onclick="exportMapImage()">
                        <i class="fas fa-camera"></i> Capture Map
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Map Area -->
        <div class="map-container">
            <div class="map-header" id="mapHeader">
                <h2 class="map-title">Live Route Visualization</h2>
                <div class="map-controls">
                    <button class="map-btn" id="editRoutesBtn"
                        style="background: linear-gradient(135deg, #ff6b35, #f7931e) !important; color: white !important; font-weight: 700 !important; padding: 12px 24px !important; font-size: 15px !important; box-shadow: 0 4px 12px rgba(255, 107, 53, 0.5) !important; border: 2px solid #ff8c61 !important;">
                        <i class="fas fa-edit" style="margin-right: 8px;"></i>âœï¸ Edit Routes
                    </button>
                    <button class="map-btn" onclick="centerOnOffice()">
                        <i class="fas fa-home"></i> Center on Office
                    </button>
                    <button class="map-btn" onclick="fitAllRoutes()" id="fitBoundsBtn">
                        <i class="fas fa-expand"></i> Fit All Routes
                    </button>
                    <button class="map-btn" onclick="togglePlaceNames()" id="togglePlaceNamesBtn">
                        <i class="fas fa-map-marker-alt"></i> Place Names
                    </button>
                    <button class="map-btn" onclick="toggleMiniMaps()" id="toggleMiniMapsBtn">
                        <i class="fas fa-th"></i> Route Thumbnails
                    </button>
                    <button class="map-btn" onclick="refreshData()">
                        <i class="fas fa-sync"></i> Refresh
                    </button>
                </div>
            </div>

            <div id="map"></div>

            <!-- Floating Legend -->
            <div class="floating-legend">
                <div class="legend-title">Map Legend</div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: linear-gradient(45deg, #ef4444, #dc2626);">
                        ðŸ¢
                    </div>
                    <span>Office Headquarters</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: linear-gradient(45deg, #3b82f6, #2563eb);">
                        ðŸš—
                    </div>
                    <span>Driver Positions</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: linear-gradient(45deg, #10b981, #059669);">
                        ðŸ‘¤
                    </div>
                    <span>User Locations</span>
                </div>
                <div class="legend-item">
                    <div class="legend-icon" style="background: linear-gradient(45deg, #f59e0b, #d97706);">
                        ðŸ›£ï¸
                    </div>
                    <span>Pickup Routes (Office â†’ Users)</span>
                </div>
                <div
                    style="margin-top: var(--space-md); padding-top: var(--space-md); border-top: 1px solid var(--gray-200);">
                    <div
                        style="font-size: 12px; font-weight: 600; color: var(--gray-700); margin-bottom: var(--space-sm);">
                        ðŸ’¡ Hover over routes to highlight â€¢ Click to view details
                    </div>
                </div>
                <div class="cluster-palette" id="clusterPalette"></div>
            </div>

            <!-- Route Info Popup -->
            <div class="route-info-popup" id="routeInfoPopup">
                <div id="routeInfoContent"></div>
            </div>

            <!-- Mini-maps Panel -->
            <div class="mini-maps-panel" id="miniMapsPanel">
                <div
                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-lg);">
                    <h3 style="margin: 0; color: var(--gray-800); font-size: 16px;">
                        <i class="fas fa-th"></i> Route Thumbnails
                    </h3>
                    <button onclick="toggleMiniMaps()"
                        style="background: none; border: none; color: var(--gray-600); cursor: pointer; font-size: 20px;">Ã—</button>
                </div>
                <div id="miniMapsContainer"></div>
            </div>

            <!-- Route Details Sliding Panel -->
            <div class="route-details-panel" id="routeDetailsPanel">
                <div class="route-details-header">
                    <div class="route-details-title">
                        <h3 id="routeDetailsTitle">
                            <i class="fas fa-route"></i> Route Details
                        </h3>
                        <button class="route-details-close" onclick="closeRouteDetails()">Ã—</button>
                    </div>
                </div>
                <div class="route-details-content" id="routeDetailsContent">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>

            <!-- Route Editor Panel -->
            <div class="route-editor-panel" id="routeEditorPanel">
                <div class="editor-header">
                    <div class="editor-title">
                        <i class="fas fa-edit"></i>
                        Route Editor
                    </div>
                    <button class="editor-close" onclick="closeRouteEditor()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <div class="editor-tabs">
                    <button class="editor-tab active" onclick="switchEditorTab('users')">
                        <i class="fas fa-users"></i> Users & Routes
                    </button>
                    <button class="editor-tab" onclick="switchEditorTab('history')">
                        <i class="fas fa-history"></i> History
                    </button>
                    <button class="editor-tab" onclick="switchEditorTab('simulator')">
                        <i class="fas fa-magic"></i> What-If
                    </button>
                </div>

                <div class="editor-content">
                    <!-- Users & Routes Tab -->
                    <div id="editorTabUsers" class="editor-tab-content">
                        <div class="user-pool">
                            <div class="pool-header">
                                <h3 style="margin: 0; color: var(--gray-800); font-size: 16px;">
                                    <i class="fas fa-inbox"></i> Unassigned Users (<span id="unassignedCount">0</span>)
                                </h3>
                                <input type="text" class="form-input" placeholder="Search users..."
                                    style="width: 200px;" oninput="searchUnassignedUsers(this.value)">
                            </div>
                            <div id="unassignedUsersContainer">
                                <!-- Draggable user cards will be inserted here -->
                            </div>
                        </div>

                        <div style="margin-bottom: var(--space-md);">
                            <h3 style="color: var(--gray-800); font-size: 16px; margin-bottom: var(--space-md);">
                                <i class="fas fa-route"></i> Routes
                            </h3>
                            <div id="routeListEditor" class="route-list">
                                <!-- Route cards will be inserted here -->
                            </div>
                        </div>

                        <div style="display: flex; gap: var(--space-sm);">
                            <button class="btn btn-primary" onclick="saveRouteChanges()">
                                <i class="fas fa-save"></i> Save All Changes
                            </button>
                            <button class="btn btn-secondary" onclick="revertRouteChanges()">
                                <i class="fas fa-undo"></i> Revert All
                            </button>
                        </div>
                    </div>

                    <!-- History Tab -->
                    <div id="editorTabHistory" class="editor-tab-content" style="display: none;">
                        <div class="history-timeline" id="historyTimeline">
                            <h3 style="color: var(--gray-800); margin-bottom: var(--space-lg);">
                                <i class="fas fa-clock"></i> Edit History
                            </h3>
                            <div id="timelineItems">
                                <!-- Timeline items will be inserted here -->
                            </div>
                        </div>
                        <div style="display: flex; gap: var(--space-sm);">
                            <button class="btn btn-secondary" onclick="undoEdit()" id="undoBtn" disabled>
                                <i class="fas fa-undo"></i> Undo
                            </button>
                            <button class="btn btn-secondary" onclick="redoEdit()" id="redoBtn" disabled>
                                <i class="fas fa-redo"></i> Redo
                            </button>
                        </div>
                    </div>

                    <!-- What-If Simulator Tab -->
                    <div id="editorTabSimulator" class="editor-tab-content" style="display: none;">
                        <div class="simulator-panel">
                            <h3 style="color: var(--gray-800); margin-bottom: var(--space-md);">
                                <i class="fas fa-flask"></i> What-If Scenario Simulator
                            </h3>
                            <p style="color: var(--gray-600); font-size: 13px; margin-bottom: var(--space-lg);">
                                Preview changes before applying them. See animated route updates and quality metrics.
                            </p>

                            <div class="simulator-preview" id="simulatorPreview">
                                <div style="text-align: center; color: var(--gray-500); padding: var(--space-xl);">
                                    <i class="fas fa-hand-pointer"
                                        style="font-size: 48px; margin-bottom: var(--space-md);"></i>
                                    <p>Make changes in the editor to preview them here</p>
                                </div>
                            </div>

                            <div class="metric-comparison" id="metricComparison" style="display: none;">
                                <div class="metric-box-compare">
                                    <div
                                        style="font-size: 11px; color: var(--gray-500); margin-bottom: var(--space-xs);">
                                        UTILIZATION</div>
                                    <div style="font-size: 20px; font-weight: 700; color: var(--primary-500);"
                                        id="simUtilization">0%</div>
                                    <div class="metric-delta" id="simUtilizationDelta"></div>
                                </div>
                                <div class="metric-box-compare">
                                    <div
                                        style="font-size: 11px; color: var(--gray-500); margin-bottom: var(--space-xs);">
                                        ROUTE QUALITY</div>
                                    <div style="font-size: 20px; font-weight: 700; color: var(--primary-500);"
                                        id="simQuality">0/10</div>
                                    <div class="metric-delta" id="simQualityDelta"></div>
                                </div>
                            </div>

                            <button class="btn btn-primary" onclick="applySimulatedChanges()"
                                style="margin-top: var(--space-lg); width: 100%;">
                                <i class="fas fa-check"></i> Apply Changes
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_URL = "/routes";
        const OFFICE_LOCATION = {lat: 30.6810489, lng: 76.7260711};

        // Colorblind-safe Okabe-ito palette (first 8 colors)
        const OKABE_ITO = [
            "#E69F00", "#56B4E9", "#009E73", "#F0E442",
            "#0072B2", "#D55E00", "#CC79A7", "#000000"
        ];

        // HSL palette generator for many routes
        function generateHslPalette(n, sat = 70, light = 50) {
            const colors = [];
            for (let i = 0; i < n; i++) {
                const hue = Math.round((i * 137.508) % 360); // golden angle for better spacing
                colors.push(`hsl(${hue}, ${sat}%, ${light}%)`);
            }
            return colors;
        }

        // Deterministic color mapping for route consistency
        function colorForRoute(index, total) {
            if (total <= 8) {
                return OKABE_ITO[index % OKABE_ITO.length];
            }
            const palette = generateHslPalette(total);
            return palette[index];
        }

        // Legacy color array for compatibility
        const ROUTE_COLORS = generateHslPalette(20);

        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================

        let allRoutes = []; // Renamed from routesData to align with usage
        let map = null;
        let markers = {
            office: null,
            drivers: [],
            users: [],
            routes: [] // For sequential route markers
        };
        let heatmap = null;
        let routeRenderers = []; // Stores renderer, routePolyline, interactionPolyline, color, index, _outline
        let optimalPaths = [];
        let spotlightMask = null; // Donut mask polygon for spotlight effect

        // Display States
        let displayState = {
            users: true,
            drivers: true,
            routeLines: true,
            heatmap: false,
            optimalPaths: false,
            showUserNames: false
        };

        // Route visibility state
        let routeVisibility = {}; // {routeIndex: boolean}
        let focusedRouteIndex = null;
        let miniMapsVisible = false;

        // Map style configurations
        let showPlaceNames = false;
        const originalMapStyles = [
            {
                elementType: "geometry",
                stylers: [{color: "#1e293b"}]
            },
            {
                elementType: "labels.text.stroke",
                stylers: [{color: "#0f172a"}]
            },
            {
                elementType: "labels.text.fill",
                stylers: [{color: "#94a3b8"}]
            },
            {
                featureType: "administrative.locality",
                elementType: "labels.text.fill",
                stylers: [{color: "#cbd5e1"}]
            },
            {
                featureType: "poi",
                elementType: "labels.text.fill",
                stylers: [{color: "#64748b"}]
            },
            {
                featureType: "poi.park",
                elementType: "geometry",
                stylers: [{color: "#334155"}]
            },
            {
                featureType: "poi.park",
                elementType: "labels.text.fill",
                stylers: [{color: "#64748b"}]
            },
            {
                featureType: "road",
                elementType: "geometry",
                stylers: [{color: "#475569"}]
            },
            {
                featureType: "road",
                elementType: "geometry.stroke",
                stylers: [{color: "#334155"}]
            },
            {
                featureType: "road",
                elementType: "labels.text.fill",
                stylers: [{color: "#94a3b8"}]
            },
            {
                featureType: "road.highway",
                elementType: "geometry",
                stylers: [{color: "#64748b"}]
            },
            {
                featureType: "road.highway",
                elementType: "geometry.stroke",
                stylers: [{color: "#475569"}]
            },
            {
                featureType: "road.highway",
                elementType: "labels.text.fill",
                stylers: [{color: "#cbd5e1"}]
            },
            {
                featureType: "transit",
                elementType: "geometry",
                stylers: [{color: "#334155"}]
            },
            {
                featureType: "transit.station",
                elementType: "labels.text.fill",
                stylers: [{color: "#64748b"}]
            },
            {
                featureType: "water",
                elementType: "geometry",
                stylers: [{color: "#0f172a"}]
            },
            {
                featureType: "water",
                elementType: "labels.text.fill",
                stylers: [{color: "#64748b"}]
            },
            {
                featureType: "water",
                elementType: "labels.text.stroke",
                stylers: [{color: "#0f172a"}]
            }
        ];

        const cleanMapStyles = [
            ...originalMapStyles,
            // Hide ALL place labels and names
            {
                featureType: "all",
                elementType: "labels.text",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "all",
                elementType: "labels.icon",
                stylers: [{visibility: "off"}]
            },
            // Hide all POI (Points of Interest) completely
            {
                featureType: "poi",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.business",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.place_of_worship",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.school",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.medical",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.government",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.attraction",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.sports_complex",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "poi.park",
                stylers: [{visibility: "off"}]
            },
            // Hide all administrative labels (cities, villages, sectors)
            {
                featureType: "administrative.locality",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "administrative.neighborhood",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "administrative.land_parcel",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "administrative.country",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "administrative.province",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            // Hide all transit labels
            {
                featureType: "transit.station",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "transit.line",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "transit",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            // Hide ALL road labels
            {
                featureType: "road",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "road.local",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "road.arterial",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            {
                featureType: "road.highway",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            // Hide water labels
            {
                featureType: "water",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            },
            // Hide landscape feature labels
            {
                featureType: "landscape",
                elementType: "labels",
                stylers: [{visibility: "off"}]
            }
        ];

        // Sidebar state
        let sidebarCollapsed = false;
        let sidebarWidth = 380;

        // ============================================================================
        // EDITOR STATE MANAGEMENT
        // ============================================================================
        let editMode = false;
        let unassignedUsers = []; // Users not currently assigned to any route
        let draggedUser = null; // The user currently being dragged
        let draggedFromRouteIndex = null; // The original route index of the dragged user
        let dragOverRouteIndex = null; // The route index the user is being dragged over
        let dirtyRoutes = new Set(); // Set of route indices that have been modified
        let routeLocks = {}; // To prevent concurrent edits on the same route if needed
        let dragOverlay = null; // A semi-transparent overlay to indicate drag target
        let dragTooltip = null; // A tooltip showing user and target route info during drag
        let editorHistory = []; // History for undo/redo functionality
        let historyIndex = -1; // Current position in history
        let originalRoutesSnapshot = null; // Snapshot of routes before editing
        let pendingChanges = {}; // Track changes made in the editor before saving
        let draggedMarker = null; // The marker currently being dragged on the map
        let draggedUserData = null; // The data associated with the dragged marker

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        function initMap() {
            map = new google.maps.Map(document.getElementById("map"), {
                center: OFFICE_LOCATION,
                zoom: 12,
                styles: cleanMapStyles, // Start with clean map (no place names)
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: true
            });

            // Initialize directions service
            directionsService = new google.maps.DirectionsService();

            // Create office marker
            createOfficeMarker();

            // Load route data
            loadRouteData();

            // Initialize sidebar state from localStorage
            initializeSidebarState();

            // Initialize sidebar resize functionality
            initializeSidebarResize();

            // Initialize edit mode toggle
            initializeEditModeToggle();
        }

        function initializeSidebarState() {
            // Load saved state from localStorage
            const savedCollapsed = localStorage.getItem('sidebarCollapsed');
            const savedWidth = localStorage.getItem('sidebarWidth');

            if (savedCollapsed === 'true') {
                sidebarCollapsed = true;
                document.querySelector('.app-container').classList.add('sidebar-collapsed');
                document.querySelector('.sidebar-collapse-btn i').className = 'fas fa-chevron-right';
            }

            if (savedWidth) {
                sidebarWidth = parseInt(savedWidth);
                applySidebarWidth(sidebarWidth);
            }
        }

        // Call after animations that change layout
        function triggerMapResizeDebounced(delay = 340) {
            setTimeout(() => {
                if (map && typeof google !== 'undefined') {
                    google.maps.event.trigger(map, 'resize');
                }
            }, delay);
        }

        function toggleSidebar() {
            sidebarCollapsed = !sidebarCollapsed;
            const container = document.querySelector('.app-container');
            const sidebar = document.querySelector('.sidebar');
            const icon = document.querySelector('.sidebar-collapse-btn i');

            if (sidebarCollapsed) {
                container.classList.add('sidebar-collapsed');
                icon.className = 'fas fa-chevron-right';
            } else {
                container.classList.remove('sidebar-collapsed');
                icon.className = 'fas fa-chevron-left';
            }

            // Update positions of other elements
            applySidebarWidth(sidebarWidth);

            // Save state to localStorage
            localStorage.setItem('sidebarCollapsed', sidebarCollapsed);

            // Trigger map resize after animation with debounce
            triggerMapResizeDebounced();
        }

        function applySidebarWidth(width) {
            const sidebar = document.querySelector('.sidebar');
            const mapHeader = document.querySelector('.map-header');
            const legend = document.querySelector('.floating-legend');

            if (sidebar) {
                sidebar.style.width = `${width}px`;
            }

            // Adjust map header and legend position based on sidebar width
            const offset = sidebarCollapsed ? 118 : width + 40;

            if (mapHeader) {
                mapHeader.style.left = `${offset}px`;
            }

            if (legend) {
                legend.style.left = `${offset}px`;
            }
        }

        function initializeSidebarResize() {
            const handle = document.getElementById('sidebarResizeHandle');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            handle.addEventListener('mousedown', (e) => {
                if (sidebarCollapsed) return;

                isResizing = true;
                startX = e.clientX;
                startWidth = sidebarWidth;
                handle.classList.add('resizing');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                const newWidth = Math.min(600, Math.max(60, startWidth + deltaX));

                sidebarWidth = newWidth;
                applySidebarWidth(newWidth);
            });

            document.addEventListener('mouseup', () => {
                if (!isResizing) return;

                isResizing = false;
                handle.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';

                // Save width to localStorage
                localStorage.setItem('sidebarWidth', sidebarWidth);

                // Trigger map resize
                google.maps.event.trigger(map, 'resize');
            });
        }

        function createOfficeMarker() {
            markers.office = new google.maps.Marker({
                position: OFFICE_LOCATION,
                map: map,
                title: "Office Headquarters",
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                        <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="24" cy="24" r="20" fill="#ef4444" stroke="#ffffff" stroke-width="4"/>
                            <text x="24" y="30" font-family="Arial" font-size="16" text-anchor="middle" fill="white">ðŸ¢</text>
                        </svg>
                    `),
                    scaledSize: new google.maps.Size(48, 48),
                    anchor: new google.maps.Point(24, 24)
                },
                zIndex: 1000
            });

            const officeInfoWindow = new google.maps.InfoWindow({
                content: `
                    <div style="padding: 15px; font-family: Inter, sans-serif; background: #0f172a; color: #f1f5f9; border-radius: 8px; min-width: 200px;">
                        <h3 style="margin: 0 0 10px 0; color: #f1f5f9; display: flex; align-items: center; gap: 8px;">
                            ðŸ¢ Office Headquarters
                        </h3>
                        <p style="margin: 0; color: #94a3b8; font-size: 13px;">Central dispatch location</p>
                        <p style="margin: 8px 0 0 0; color: #64748b; font-size: 12px;">
                            ðŸ“ ${OFFICE_LOCATION.lat.toFixed(6)}, ${OFFICE_LOCATION.lng.toFixed(6)}
                        </p>
                    </div>
                `
            });

            markers.office.addListener("click", () => {
                closeAllInfoWindows();
                officeInfoWindow.open(map, markers.office);
            });
        }

        async function loadRouteData() {
            showLoading();
            try {
                const response = await fetch(API_URL);
                const responseData = await response.json();

                // Handle unified response format
                let routes = [];
                if (responseData && responseData.data && Array.isArray(responseData.data)) {
                    routes = responseData.data;
                    // Extract unassigned users and drivers if available
                    unassignedUsers = responseData.unassignedUsers || [];
                    unassignedDrivers = responseData.unassignedDrivers || [];
                } else if (Array.isArray(responseData)) {
                    // Backward compatibility for old format
                    routes = responseData;
                    unassignedUsers = [];
                    unassignedDrivers = [];
                } else {
                    throw new Error('Invalid route data format');
                }

                // Normalize user coordinate data to handle both lat/lng and latitude/longitude formats
                routes = routes.map(route => ({
                    ...route,
                    assigned_users: route.assigned_users.map(user => normalizeUserData(user))
                }));

                // Also normalize unassigned users
                unassignedUsers = unassignedUsers.map(user => normalizeUserData(user));

                allRoutes = routes;
                hideLoading();
                updateUI();
                renderMap();
                // Initialize editor state if in edit mode
                if (editMode) {
                    initializeEditorState();
                }
            } catch (error) {
                console.error('Error loading route data:', error);
                hideLoading();
                showAlert('error', 'Failed to load route data. Please check if the server is running.');
            }
        }

        function prepareEditorData() {
            // Clear current unassigned users array
            unassignedUsers = [];

            // The unassigned users should already be loaded from API response
            // No need to process since they're already in the correct format

            // Update UI
            const unassignedCount = document.getElementById('unassignedCount');
            if (unassignedCount) {
                unassignedCount.textContent = unassignedUsers.length;
            }
        }

        function loadRoutesIntoEditor() {
            const container = document.getElementById('routeList');
            if (!container) return;

            container.innerHTML = '';

            allRoutes.forEach((route, index) => {
                const routeCard = createRouteCard(route, index);
                if (routeCard) {
                    container.appendChild(routeCard);
                }
            });
        }

        // Data normalization function to handle different coordinate field names
        function normalizeUserData(user) {
            return {
                ...user,
                lat: user.lat || user.latitude,
                lng: user.lng || user.longitude
            };
        }

        // Helper function to get vehicle capacity from different field names
        function getVehicleCapacity(route) {
            return route.capacity || getVehicleCapacity(route) || 4; // Default to 4 if not specified
        }

        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function updateUI() {
            populateRouteDropdown();
            updateStats();
            updateAnalytics();
            createClusterPalette();
        }

        function populateRouteDropdown() {
            const select = document.getElementById("clusterSelect");
            select.innerHTML = '<option value="all">All Routes</option>';

            allRoutes.forEach((route, index) => {
                const option = document.createElement("option");
                option.value = index;
                option.text = `Route ${index + 1} - ${route.assigned_users.length} users`;
                select.appendChild(option);
            });
        }

        function addRouteInteractions(renderer, outline, routeIndex, color) {
            // This function is no longer directly used for route interaction.
            // Interactions are handled via `createGlassmorphicRoute` and its event listeners.
        }

        function createClusterPalette() {
            const container = document.getElementById('clusterPalette');
            container.innerHTML = '';

            // Add "All Routes" button first
            const allRoutesBtn = document.createElement('div');
            allRoutesBtn.className = 'cluster-color';
            allRoutesBtn.style.background = 'linear-gradient(45deg, #6366f1, #4f46e5)';
            allRoutesBtn.style.width = 'auto';
            allRoutesBtn.style.padding = '0 10px';
            allRoutesBtn.title = 'Show all routes';
            allRoutesBtn.textContent = 'All';
            allRoutesBtn.onclick = () => showAllRoutes();
            container.appendChild(allRoutesBtn);

            // Add numbered route buttons
            allRoutes.forEach((route, index) => {
                const colorDiv = document.createElement('div');
                colorDiv.className = 'cluster-color';
                const routeColor = colorForRoute(index, allRoutes.length);
                colorDiv.style.background = `linear-gradient(45deg, ${routeColor}, ${adjustBrightness(routeColor, -20)})`;
                colorDiv.title = `Route ${index + 1} - Click to view details`;
                colorDiv.textContent = index + 1;
                colorDiv.onclick = () => {
                    // Show route details panel (same as dropdown selection)
                    showRouteDetails(index);

                    // Also update the dropdown to match
                    const dropdown = document.getElementById('clusterSelect');
                    if (dropdown) {
                        dropdown.value = index;
                    }
                };
                container.appendChild(colorDiv);
            });
        }

        function updateInteractiveLegend() {
            // This function is kept for compatibility but the interactive legend
            // is now handled through the cluster palette and `showRouteDetails`.
            console.log('Interactive legend updated via cluster palette and route details panel');
        }

        function toggleRouteVisibility(index, visible) {
            routeVisibility[index] = visible;
            renderMap();
        }

        function isolateRoute(index) {
            // Hide all routes except the selected one
            allRoutes.forEach((_, i) => {
                routeVisibility[i] = (i === index);
            });
            renderMap();
            updateInteractiveLegend();
        }

        function focusRoute(index) {
            // This function is now replaced by showRouteDetails which opens the sliding panel.
            // It calls highlightRouteOnHover which handles the visual feedback.
            showRouteDetails(index);
        }

        function _setRouteStyle(item, opts) {
            // If we have a DirectionsRenderer, change its polylineOptions
            if (item.renderer && typeof item.renderer.setOptions === 'function') {
                item.renderer.setOptions({
                    polylineOptions: Object.assign({}, item.renderer.get('polylineOptions') || {}, {
                        strokeOpacity: opts.opacity,
                        strokeWeight: opts.weight,
                        zIndex: opts.zIndex,
                        strokeColor: opts.color
                    })
                });
            }

            // If routePolyline is a google.maps.Polyline instance
            if (item.routePolyline && typeof item.routePolyline.setOptions === 'function') {
                item.routePolyline.setOptions({
                    strokeOpacity: opts.opacity,
                    strokeWeight: opts.weight,
                    zIndex: opts.zIndex,
                    strokeColor: opts.color
                });
            }

            // fallback polyline key (your fallback route uses fallbackRoute)
            if (item.fallbackPolyline && typeof item.fallbackPolyline.setOptions === 'function') {
                item.fallbackPolyline.setOptions({
                    strokeOpacity: opts.opacity,
                    strokeWeight: opts.weight,
                    zIndex: opts.zIndex,
                    strokeColor: opts.color
                });
            }
        }

        // Hover delay timer for spotlight effect
        let spotlightDelayTimer = null;

        function highlightRouteOnHover(routeIndex) {
            focusedRouteIndex = routeIndex;

            // Find the route item to highlight
            const targetRoute = routeRenderers.find(item => item.index === routeIndex);
            if (!targetRoute) return;

            // Only show spotlight effect when all routes are visible
            const allRoutesVisible = allRoutes.length === routeRenderers.length;

            // Keep all routes visible, just elevate the hovered one
            routeRenderers.forEach((item, i) => {
                if (item.index === routeIndex) {
                    // Make hovered route visually dominant with high zIndex
                    _setRouteStyle(item, {opacity: 1, weight: 9, zIndex: 9999, color: item.color || '#fff'});

                    // Create/show outline for extra contrast (increased opacity for glass background)
                    if (!item._outline && item.interactionPolyline && item.interactionPolyline.getPath) {
                        const path = item.interactionPolyline.getPath();
                        if (path) {
                            item._outline = new google.maps.Polyline({
                                path: path.getArray ? path.getArray() : path,
                                geodesic: true,
                                strokeColor: '#ffffff',
                                strokeWeight: 14,
                                strokeOpacity: 0.5, // Increased opacity for better visibility
                                zIndex: 9900,
                                map: map
                            });
                        }
                    } else if (item._outline) {
                        item._outline.setMap(map);
                        item._outline.setOptions({strokeOpacity: 0.5});
                    }
                } else {
                    // Keep other routes at normal visibility
                    _setRouteStyle(item, {opacity: 0.8, weight: 6, zIndex: 300, color: item.color});

                    // Hide outline if exists
                    if (item._outline) {
                        item._outline.setMap(null);
                    }
                }
            });

            // Clear any existing spotlight delay timer
            if (spotlightDelayTimer) {
                clearTimeout(spotlightDelayTimer);
            }

            // Only create spotlight effect after 2 seconds of hovering (and only when all routes visible)
            if (allRoutesVisible) {
                spotlightDelayTimer = setTimeout(() => {
                    createSpotlightMask(targetRoute);
                }, 2000); // 2 second delay
            }

            // Dim all markers EXCEPT those belonging to the highlighted route
            markers.users.forEach(u => {
                if (u && u.marker) {
                    if (u.routeIndex === routeIndex) {
                        u.marker.setOpacity(1); // Keep highlighted route's users bright
                        u.marker.setZIndex(9998); // Above the mask
                    } else {
                        u.marker.setOpacity(0.3); // Dim other users
                        u.marker.setZIndex(400); // Below the mask
                    }
                }
            });

            markers.drivers.forEach(d => {
                if (d && d.marker) {
                    if (d.routeIndex === routeIndex) {
                        d.marker.setOpacity(1); // Keep highlighted route's driver bright
                        d.marker.setZIndex(9998); // Above the mask
                    } else {
                        d.marker.setOpacity(0.3); // Dim other drivers
                        d.marker.setZIndex(400); // Below the mask
                    }
                }
            });

            // Highlight corresponding legend item
            document.querySelectorAll('.cluster-color').forEach((el, idx) => {
                el.classList.remove('active');
                if (idx === routeIndex + 1) {
                    el.classList.add('active');
                }
            });
        }

        function createSpotlightMask(routeItem) {
            // Remove existing mask efficiently
            if (spotlightMask) {
                spotlightMask.setMap(null);
                spotlightMask = null;
            }

            // Early return if Turf.js is not available
            if (typeof turf === 'undefined') {
                console.warn('Turf.js not loaded. Spotlight disabled.');
                return;
            }

            try {
                // Use cached bounds if available
                const bounds = map.getBounds();
                if (!bounds) return;

                const ne = bounds.getNorthEast();
                const sw = bounds.getSouthWest();

                // Create outer ring covering beyond visible map area
                const padding = 10; // degrees of padding
                const outer = [
                    {lat: ne.lat() + padding, lng: sw.lng() - padding},  // NW
                    {lat: ne.lat() + padding, lng: ne.lng() + padding},  // NE
                    {lat: sw.lat() - padding, lng: ne.lng() + padding},  // SE
                    {lat: sw.lat() - padding, lng: sw.lng() - padding}   // SW
                ];

                // Get the route path
                let routePath = null;

                if (routeItem.interactionPolyline && routeItem.interactionPolyline.getPath) {
                    const path = routeItem.interactionPolyline.getPath();
                    routePath = path.getArray ? path.getArray() : path;
                } else if (routeItem.routePolyline && routeItem.routePolyline.getPath) {
                    const path = routeItem.routePolyline.getPath();
                    routePath = path.getArray ? path.getArray() : path;
                }

                if (!routePath || routePath.length === 0) {
                    console.warn('No route path available for spotlight');
                    return;
                }

                // Convert route path to GeoJSON LineString
                const lineCoords = routePath.map(point => [
                    typeof point.lng === 'function' ? point.lng() : point.lng,
                    typeof point.lat === 'function' ? point.lat() : point.lat
                ]);

                const line = turf.lineString(lineCoords);

                // Create a buffer around the route (10 meters = 0.01km)
                const buffered = turf.buffer(line, 0.01, {units: 'kilometers'});

                // Extract buffered coordinates for the hole
                const holeCoords = buffered.geometry.coordinates[0].map(coord => ({
                    lng: coord[0],
                    lat: coord[1]
                }));

                // Create the donut mask polygon
                spotlightMask = new google.maps.Polygon({
                    paths: [outer, holeCoords],
                    fillColor: '#000000',
                    fillOpacity: 0.7,
                    strokeOpacity: 0,
                    strokeWeight: 0,
                    map: map,
                    zIndex: 500,
                    clickable: false
                });

                console.log('âœ¨ Spotlight mask created successfully with 10m buffer');

            } catch (error) {
                console.warn('Failed to create spotlight mask:', error);
            }
        }


        function unhighlightAllRoutes() {
            focusedRouteIndex = null;

            // Clear spotlight delay timer
            if (spotlightDelayTimer) {
                clearTimeout(spotlightDelayTimer);
                spotlightDelayTimer = null;
            }

            // Remove spotlight mask
            if (spotlightMask) {
                spotlightMask.setMap(null);
                spotlightMask = null;
            }

            // Restore all routes to normal
            routeRenderers.forEach((item) => {
                _setRouteStyle(item, {opacity: 0.8, weight: 6, zIndex: 300, color: item.color});

                // Hide outline if any
                if (item._outline) {
                    item._outline.setMap(null);
                }
            });

            // Restore all markers to full opacity and normal zIndex
            markers.users.forEach(u => {
                if (u && u.marker) {
                    u.marker.setOpacity(1);
                    u.marker.setZIndex(300);
                }
            });
            markers.drivers.forEach(d => {
                if (d && d.marker) {
                    d.marker.setOpacity(1);
                    d.marker.setZIndex(500);
                }
            });

            // Remove legend highlights
            document.querySelectorAll('.cluster-color').forEach(el => {
                el.classList.remove('active');
            });
        }

        // Cache for route details to avoid re-rendering
        const routeDetailsCache = {};

        function showRouteDetails(routeIndex) {
            const route = allRoutes[routeIndex];
            if (!route) return;

            const panel = document.getElementById('routeDetailsPanel');
            const title = document.getElementById('routeDetailsTitle');
            const content = document.getElementById('routeDetailsContent');

            const routeColor = colorForRoute(routeIndex, allRoutes.length);
            const utilization = (route.assigned_users.length / getVehicleCapacity(route)).toFixed(1);

            // Keep the route highlighted
            highlightRouteOnHover(routeIndex);

            // Only show spotlight effect when all routes are visible
            const allRoutesVisible = allRoutes.length === routeRenderers.length;
            if (allRoutesVisible) {
                createSpotlightMask(routeRenderers.find(r => r.index === routeIndex));
            }

            // Only fit bounds if panel was just opened (not already active)
            const wasActive = panel.classList.contains('active');
            if (!wasActive && route.assigned_users.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                bounds.extend(OFFICE_LOCATION);
                route.assigned_users.forEach(user => {
                    bounds.extend(new google.maps.LatLng(parseFloat(user.lat), parseFloat(user.lng)));
                });
                map.fitBounds(bounds);
                triggerMapResizeDebounced();
            }

            // Update title immediately
            title.innerHTML = `
                <i class="fas fa-route" style="color: ${routeColor}"></i>
                Route ${routeIndex + 1}
            `;

            // Use cached content or generate new
            if (routeDetailsCache[routeIndex]) {
                content.innerHTML = routeDetailsCache[routeIndex];
            } else {
                const detailsHtml = `
                <!-- Route Metrics -->
                <div class="route-metrics">
                    <div class="metric-box">
                        <div class="metric-box-value">${utilization}%</div>
                        <div class="metric-box-label">Utilization</div>
                        <svg width="60" height="60" viewBox="0 0 60 60" style="margin: 8px auto 0; display: block;">
                            <circle cx="30" cy="30" r="25" fill="none" stroke="#334155" stroke-width="8"/>
                            <circle cx="30" cy="30" r="25" fill="none" stroke="${routeColor}" stroke-width="8"
                                stroke-dasharray="${(utilization / 100 * 157).toFixed(1)} 157"
                                transform="rotate(-90 30 30)"
                                style="transition: stroke-dasharray 0.3s ease"/>
                            <text x="30" y="35" text-anchor="middle" fill="#f1f5f9" font-size="12" font-weight="bold">${utilization}%</text>
                        </svg>
                    </div>
                    <div class="metric-box">
                        <div class="metric-box-value">${route.assigned_users.length}/${getVehicleCapacity(route)}</div>
                        <div class="metric-box-label">Capacity</div>
                        <svg width="100%" height="40" viewBox="0 0 100 40" style="margin-top: 8px;">
                            <rect x="0" y="15" width="${(route.assigned_users.length / getVehicleCapacity(route) * 100)}" height="10" fill="${routeColor}" rx="5"/>
                            <rect x="${(route.assigned_users.length / getVehicleCapacity(route) * 100)}" y="15" width="${((getVehicleCapacity(route) - route.assigned_users.length) / getVehicleCapacity(route) * 100)}" height="10" fill="#334155" rx="5"/>
                            <text x="2" y="12" fill="#94a3b8" font-size="8">Occupied</text>
                            <text x="${(route.assigned_users.length / getVehicleCapacity(route) * 100) + 2}" y="12" fill="#64748b" font-size="8">Available</text>
                        </svg>
                    </div>
                </div>

                <!-- Driver Section -->
                <div class="details-section">
                    <div class="details-section-title">
                        <i class="fas fa-id-card"></i> Driver Information
                    </div>
                    <div class="details-grid">
                        <div class="details-row">
                            <span class="details-label">Driver ID</span>
                            <span class="details-value">${route.driver_id}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Name</span>
                            <span class="details-value">${route.first_name || 'N/A'} ${route.last_name || ''}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Email</span>
                            <span class="details-value">${route.email || 'N/A'}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Location</span>
                            <span class="details-value">${parseFloat(route.latitude).toFixed(4)}, ${parseFloat(route.longitude).toFixed(4)}</span>
                        </div>
                    </div>
                </div>

                <!-- Vehicle Section -->
                <div class="details-section">
                    <div class="details-section-title">
                        <i class="fas fa-car"></i> Vehicle Information
                    </div>
                    <div class="details-grid">
                        <div class="details-row">
                            <span class="details-label">Vehicle ID</span>
                            <span class="details-value">${route.vehicle_id || 'N/A'}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Vehicle Name</span>
                            <span class="details-value">${route.vehicle_name || 'N/A'}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Vehicle Number</span>
                            <span class="details-value">${route.vehicle_no || 'N/A'}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Capacity</span>
                            <span class="details-value">${getVehicleCapacity(route)} passengers</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Color</span>
                            <span class="details-value">${route.color || 'N/A'}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Registration No</span>
                            <span class="details-value">${route.registration_no || 'N/A'}</span>
                        </div>
                    </div>
                </div>

                <!-- Users Section -->
                <div class="details-section">
                    <div class="details-section-title">
                        <i class="fas fa-users"></i> Assigned Users (${route.assigned_users.length})
                    </div>
                    ${route.assigned_users.map(user => `
                        <div class="user-card">
                            <div class="user-card-header">
                                <span class="user-card-name">${user.first_name || `User ${user.user_id}`}</span>
                                <span class="user-card-id">${user.user_id}</span>
                            </div>
                            <div class="user-card-details">
                                <div>ðŸ“§ ${user.email || 'No email'}</div>
                                <div>ðŸ“ ${parseFloat(user.lat).toFixed(4)}, ${parseFloat(user.lng).toFixed(4)}</div>
                                <div>ðŸ¢ ${user.office_distance} km from office</div>
                                ${user.address ? `<div>ðŸ  ${user.address}</div>` : ''}
                                ${user.employee_shift ? `<div>â° ${user.employee_shift}</div>` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>

                <!-- Route Statistics -->
                <div class="details-section">
                    <div class="details-section-title">
                        <i class="fas fa-chart-line"></i> Route Statistics
                    </div>
                    <div class="details-grid">
                        <div class="details-row">
                            <span class="details-label">Efficiency Rating</span>
                            <span class="details-value">${utilization >= 80 ? 'ðŸŸ¢ Excellent' : utilization >= 50 ? 'ðŸŸ¡ Good' : 'ðŸ”´ Needs Improvement'}</span>
                        </div>
                        <div class="details-row">
                            <span class="details-label">Route Type</span>
                            <span class="details-value">Office-centric pickup</span>
                        </div>
                    </div>
                </div>
            `;
                routeDetailsCache[routeIndex] = detailsHtml;
                content.innerHTML = detailsHtml;
            }

            // Use CSS class toggle for smoother animation
            requestAnimationFrame(() => {
                panel.classList.add('active');
            });
        }

        function closeRouteDetails() {
            document.getElementById('routeDetailsPanel').classList.remove('active');
            // Unhighlight the route and remove spotlight effect
            unhighlightAllRoutes();
        }

        // Debounced render function for performance
        let renderTimeout = null;
        function renderMap() {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(() => {
                performRender();
            }, 50);
        }

        function performRender() {
            clearMap();

            let totalUsers = 0;
            let heatmapData = [];

            // Use requestAnimationFrame for smoother rendering
            requestAnimationFrame(() => {
                allRoutes.forEach((route, index) => {
                    const color = ROUTE_COLORS[index % ROUTE_COLORS.length];
                    renderRoute(route, index, color);

                    route.assigned_users.forEach(user => {
                        totalUsers++;
                        heatmapData.push(new google.maps.LatLng(parseFloat(user.lat), parseFloat(user.lng)));
                    });
                });

                if (displayState.heatmap && heatmapData.length > 0) {
                    createHeatmap(heatmapData);
                }

                updateDisplayButtons();
                updateMapHeaderControls(); // Update based on edit mode
            });
        }

        function renderRoute(route, index, color) {
            const driverLat = parseFloat(route.latitude);
            const driverLng = parseFloat(route.longitude);
            const utilization = route.assigned_users.length / getVehicleCapacity(route);

            // Initialize visibility if not set
            if (routeVisibility[index] === undefined) {
                routeVisibility[index] = true;
            }

            // Skip rendering if route is hidden
            if (!routeVisibility[index]) {
                return;
            }

            // Use deterministic color
            const routeColor = colorForRoute(index, allRoutes.length);

            // Create glassmorphic driver marker
            if (displayState.drivers) {
                // Glassmorphism SVG with blur and transparency
                const driverSvg = `<svg width="56" height="56" viewBox="0 0 56 56" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="grad${index}" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:${routeColor};stop-opacity:0.85" />
                            <stop offset="100%" style="stop-color:${adjustBrightness(routeColor, -30)};stop-opacity:0.9" />
                        </linearGradient>
                        <filter id="blur${index}" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" />
                        </filter>
                        <filter id="glow${index}">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    <!-- Outer glow -->
                    <circle cx="28" cy="28" r="26" fill="${routeColor}" opacity="0.2" filter="url(#blur${index})"/>
                    <!-- Glass circle -->
                    <circle cx="28" cy="28" r="24" fill="url(#grad${index})" stroke="#ffffff" stroke-width="3" stroke-opacity="0.6" filter="url(#glow${index})"/>
                    <!-- Inner shine -->
                    <circle cx="28" cy="28" r="24" fill="url(#grad${index})" opacity="0.3"/>
                    <ellipse cx="28" cy="22" rx="18" ry="12" fill="#ffffff" opacity="0.25"/>
                    <!-- Icon -->
                    <text x="28" y="34" font-family="Arial" font-size="18" text-anchor="middle" fill="white" filter="url(#glow${index})">ðŸš—</text>
                    <text x="28" y="46" font-family="Arial" font-size="10" text-anchor="middle" fill="white" font-weight="bold">${index + 1}</text>
                </svg>`;

                const driverMarker = new google.maps.Marker({
                    position: {lat: driverLat, lng: driverLng},
                    map: map,
                    title: `Driver ${route.driver_id}`,
                    icon: {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(driverSvg),
                        scaledSize: new google.maps.Size(56, 56),
                        anchor: new google.maps.Point(28, 28)
                    },
                    zIndex: 500,
                    optimized: true
                });

                const driverInfo = createDriverInfoWindow(route, index, utilization);
                driverMarker.addListener("click", () => {
                    closeAllInfoWindows();
                    driverInfo.open(map, driverMarker);
                    showRouteInfo(route, index);
                });

                markers.drivers.push({marker: driverMarker, infoWindow: driverInfo, routeIndex: index});
            }

            // Create enhanced user markers
            route.assigned_users.forEach((user, userIndex) => {
                const userLat = parseFloat(user.lat);
                const userLng = parseFloat(user.lng);

                if (displayState.users) {
                    // Determine what to display based on showUserNames mode
                    let markerIcon;
                    if (displayState.showUserNames) {
                        // Glassmorphic name label
                        const userName = user.first_name || `User ${user.user_id}`;
                        const textWidth = userName.length * 8 + 16;
                        markerIcon = {
                            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                <svg width="${textWidth}" height="28" viewBox="0 0 ${textWidth} 28" xmlns="http://www.w3.org/2000/svg">
                                    <defs>
                                        <linearGradient id="textbg${index}_${userIndex}" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style="stop-color:${routeColor};stop-opacity:0.8" />
                                            <stop offset="100%" style="stop-color:${adjustBrightness(routeColor, -20)};stop-opacity:0.85" />
                                        </linearGradient>
                                        <filter id="textblur${index}_${userIndex}">
                                            <feGaussianBlur in="SourceGraphic" stdDeviation="0.8" />
                                        </filter>
                                        <filter id="textshadow${index}_${userIndex}">
                                            <feDropShadow dx="2" dy="2" stdDeviation="2" flood-opacity="0.4"/>
                                        </filter>
                                    </defs>
                                    <!-- Outer glow -->
                                    <rect x="0" y="0" width="${textWidth}" height="28" rx="14" fill="${routeColor}" opacity="0.2" filter="url(#textblur${index}_${userIndex})"/>
                                    <!-- Glass background -->
                                    <rect x="0" y="0" width="${textWidth}" height="28" rx="14" fill="url(#textbg${index}_${userIndex})" stroke="#ffffff" stroke-width="1.5" stroke-opacity="0.5" filter="url(#textshadow${index}_${userIndex})"/>
                                    <!-- Inner highlight -->
                                    <rect x="2" y="2" width="${textWidth - 4}" height="12" rx="10" fill="#ffffff" opacity="0.2"/>
                                    <text x="${textWidth / 2}" y="18" font-family="Arial, sans-serif" font-size="12" font-weight="bold" text-anchor="middle" fill="white">${userName}</text>
                                </svg>
                            `),
                            scaledSize: new google.maps.Size(textWidth, 28),
                            anchor: new google.maps.Point(textWidth / 2, 14)
                        };
                    } else {
                        // Glassmorphic icon
                        markerIcon = {
                            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                <svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg">
                                    <defs>
                                        <linearGradient id="usergrad${index}_${userIndex}" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style="stop-color:${routeColor};stop-opacity:0.8" />
                                            <stop offset="100%" style="stop-color:${adjustBrightness(routeColor, -20)};stop-opacity:0.9" />
                                        </linearGradient>
                                        <filter id="userblur${index}_${userIndex}">
                                            <feGaussianBlur in="SourceGraphic" stdDeviation="1" />
                                        </filter>
                                        <filter id="userglow${index}_${userIndex}">
                                            <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                                            <feMerge>
                                                <feMergeNode in="coloredBlur"/>
                                                <feMergeNode in="SourceGraphic"/>
                                            </feMerge>
                                        </filter>
                                    </defs>
                                    <!-- Outer glow -->
                                    <circle cx="18" cy="18" r="14" fill="${routeColor}" opacity="0.2" filter="url(#userblur${index}_${userIndex})"/>
                                    <!-- Glass circle -->
                                    <circle cx="18" cy="18" r="13" fill="url(#usergrad${index}_${userIndex})" stroke="#ffffff" stroke-width="2" stroke-opacity="0.6" filter="url(#userglow${index}_${userIndex})"/>
                                    <!-- Inner highlight -->
                                    <ellipse cx="18" cy="14" rx="10" ry="6" fill="#ffffff" opacity="0.25"/>
                                    <text x="18" y="22" font-family="Arial" font-size="14" text-anchor="middle" fill="white">ðŸ‘¤</text>
                                </svg>
                            `),
                            scaledSize: new google.maps.Size(36, 36),
                            anchor: new google.maps.Point(18, 18)
                        };
                    }

                    const userMarker = new google.maps.Marker({
                        position: {lat: userLat, lng: userLng},
                        map: map,
                        title: `User ${user.user_id}`,
                        icon: markerIcon,
                        zIndex: 300,
                        animation: google.maps.Animation.DROP
                    });

                    // Store user data on the marker for drag/drop
                    userMarker.userData = user;
                    userMarker.routeIndex = index;

                    const userInfo = createUserInfoWindow(user, route, index);
                    userMarker.addListener("click", () => {
                        closeAllInfoWindows();
                        userInfo.open(map, userMarker);
                    });

                    // Add hover animation
                    userMarker.addListener("mouseover", () => {
                        userMarker.setAnimation(google.maps.Animation.BOUNCE);
                    });
                    userMarker.addListener("mouseout", () => {
                        userMarker.setAnimation(null);
                    });

                    markers.users.push({marker: userMarker, infoWindow: userInfo, routeIndex: index});
                }
            });

            // Create sequential route for this driver after processing all users
            if (displayState.routeLines && route.assigned_users.length > 0) {
                createSequentialRoute(route, routeColor, index);
            }

            // Create optimal path if enabled
            if (displayState.optimalPaths) {
                createOptimalPath(route, routeColor);
            }
        }

        function createDriverInfoWindow(route, index, utilization) {
            const efficiencyRating = utilization >= 0.8 ? 'ðŸŸ¢ Excellent' : utilization >= 0.6 ? 'ðŸŸ¡ Good' : 'ðŸ”´ Needs Improvement';
            const utilizationPercent = (utilization * 100).toFixed(1);
            const routeColor = colorForRoute(index, allRoutes.length);

            const content = `
                <div style="font-family: Inter, sans-serif; min-width: 260px; padding: 14px; background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(24px) saturate(180%); -webkit-backdrop-filter: blur(24px) saturate(180%); color: #f1f5f9; border-radius: 14px; border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255, 255, 255, 0.08);">
                        <div style="width: 34px; height: 34px; background: linear-gradient(135deg, ${routeColor}66, ${adjustBrightness(routeColor, -20)}88); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 14px; box-shadow: 0 4px 15px rgba(0,0,0,0.4); border: 1px solid rgba(255, 255, 255, 0.15);">
                            ðŸš—
                        </div>
                        <div>
                            <h3 style="margin: 0; color: #f1f5f9; font-size: 15px; font-weight: 600;">Driver ${route.driver_id}</h3>
                            <p style="margin: 0; color: #94a3b8; font-size: 11px;">Route ${index + 1}</p>
                        </div>
                    </div>

                    <div style="display: grid; gap: 7px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #94a3b8; font-size: 11px;">ðŸš™ Vehicle</span>
                            <span style="font-weight: 500; color: #f1f5f9; font-size: 11px;">${route.vehicle_id}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #94a3b8; font-size: 11px;">ðŸ“Š Capacity</span>
                            <span style="font-weight: 500; color: #f1f5f9; font-size: 11px;">${route.assigned_users.length}/${getVehicleCapacity(route)}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #94a3b8; font-size: 11px;">âš¡ Efficiency</span>
                            <span style="font-weight: 500; color: #f1f5f9; font-size: 11px;">${efficiencyRating}</span>
                        </div>
                    </div>

                    <div style="background: rgba(30, 41, 59, 0.3); border-radius: 8px; padding: 8px; backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.05);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 9px; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em;">Utilization</span>
                            <span style="font-size: 10px; color: #f1f5f9; font-weight: 600;">${utilizationPercent}%</span>
                        </div>
                        <div style="width: 100%; height: 5px; background: rgba(51, 65, 85, 0.5); border-radius: 3px; overflow: hidden;">
                            <div style="height: 100%; background: linear-gradient(90deg, ${routeColor}, ${adjustBrightness(routeColor, 20)}); width: ${utilizationPercent}%; transition: width 0.3s ease; box-shadow: 0 0 8px ${routeColor}60;"></div>
                        </div>
                    </div>
                </div>
            `;

            return new google.maps.InfoWindow({
                content,
                pixelOffset: new google.maps.Size(0, -10),
                disableAutoPan: false,
                maxWidth: 300
            });
        }

        function createUserInfoWindow(user, route, routeIndex) {
            const distanceToDriver = haversineDistance(
                route.latitude, route.longitude,
                user.lat, user.lng
            );
            const routeColor = colorForRoute(routeIndex, allRoutes.length);

            const content = `
                <div style="font-family: Inter, sans-serif; min-width: 240px; padding: 14px; background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(24px) saturate(180%); -webkit-backdrop-filter: blur(24px) saturate(180%); color: #f1f5f9; border-radius: 14px; border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid rgba(255, 255, 255, 0.08);">
                        <div style="width: 32px; height: 32px; background: linear-gradient(135deg, ${routeColor}66, ${adjustBrightness(routeColor, -20)}88); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 13px; box-shadow: 0 4px 15px rgba(0,0,0,0.4); border: 1px solid rgba(255, 255, 255, 0.15);">
                            ðŸ‘¤
                        </div>
                        <div>
                            <h4 style="margin: 0; color: #f1f5f9; font-size: 14px; font-weight: 600;">${user.first_name || `User ${user.user_id}`}</h4>
                            <p style="margin: 0; color: #94a3b8; font-size: 10px;">Route ${routeIndex + 1}</p>
                        </div>
                    </div>

                    <div style="display: grid; gap: 6px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #94a3b8; font-size: 10px;">ðŸ¢ Office</span>
                            <span style="font-weight: 500; color: #f1f5f9; font-size: 10px;">${user.office_distance} km</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #94a3b8; font-size: 10px;">ðŸš— Driver</span>
                            <span style="font-weight: 500; color: #f1f5f9; font-size: 10px;">${distanceToDriver.toFixed(1)} km</span>
                        </div>
                        ${user.email ? `
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #94a3b8; font-size: 10px;">ðŸ“§</span>
                            <span style="font-weight: 500; color: #f1f5f9; font-size: 9px;">${user.email}</span>
                        </div>
                        ` : ''}
                    </div>

                    <div style="background: rgba(30, 41, 59, 0.3); padding: 7px; border-radius: 8px; text-align: center; backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.05);">
                        <p style="margin: 0; font-size: 9px; color: #94a3b8;">
                            ðŸ“ ${parseFloat(user.lat).toFixed(4)}, ${parseFloat(user.lng).toFixed(4)}
                        </p>
                    </div>
                </div>
            `;

            return new google.maps.InfoWindow({
                content,
                pixelOffset: new google.maps.Size(0, -10),
                disableAutoPan: false,
                maxWidth: 280
            });
        }

        // ============================================================================
        // ENHANCED ROUTE HOVER DETECTION (Glassmorphism Style)
        // ============================================================================
        
        // Storage for route polylines
        const routeLayers = [];

        /**
         * Compute zoom-adaptive hit weight for better hover across zoom levels
         */
        function computeAdaptiveHitWeight(hitBase = 40) {
            const zoom = Math.max(1, Math.round(map.getZoom ? map.getZoom() : 14));
            const raw = Math.round(hitBase * (16 / zoom));
            return Math.min(100, Math.max(30, raw));
        }

        /**
         * Create glassmorphism-styled route with enhanced hover detection
         */
        function createGlassmorphicRoute(pathCoords, color, routeIndex, opts = {}) {
            const baseWeight = opts.baseWeight ?? 5;
            const hitBase = opts.hitBase ?? 40;
            const zIndex = opts.zIndex ?? 300;

            // Glass-style visible polyline with blur effect
            const visible = new google.maps.Polyline({
                path: pathCoords,
                strokeColor: color,
                strokeOpacity: 0.7, // Semi-transparent for glass effect
                strokeWeight: baseWeight,
                clickable: false,
                geodesic: true,
                zIndex: zIndex,
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: color,
                        fillOpacity: 0.3,
                        strokeColor: '#ffffff',
                        strokeOpacity: 0.5,
                        strokeWeight: 1,
                        scale: 3
                    },
                    offset: '0',
                    repeat: '40px'
                }]
            });
            visible.setMap(map);

            // Wide invisible hit-area for easy hovering
            const hitArea = new google.maps.Polyline({
                path: pathCoords,
                strokeColor: color,
                strokeOpacity: 0.01, // Nearly invisible but clickable
                strokeWeight: computeAdaptiveHitWeight(hitBase),
                clickable: true,
                geodesic: true,
                zIndex: zIndex + 1
            });
            hitArea.setMap(map);

            // Store original styles
            visible.__orig = {
                strokeWeight: baseWeight,
                strokeOpacity: 0.7,
                zIndex: zIndex
            };

            // Hover handlers
            const onHoverStart = () => {
                if (!editMode) {
                    // Glassmorphic highlight effect
                    visible.setOptions({
                        strokeWeight: baseWeight * 1.8,
                        strokeOpacity: 0.95,
                        zIndex: 9999
                    });

                    // Add outer glow
                    if (!visible.__glow) {
                        visible.__glow = new google.maps.Polyline({
                            path: pathCoords,
                            strokeColor: '#ffffff',
                            strokeOpacity: 0.3,
                            strokeWeight: baseWeight * 3,
                            clickable: false,
                            zIndex: 9998,
                            map: map
                        });
                    }

                    const mapDiv = map.getDiv && map.getDiv();
                    if (mapDiv) mapDiv.style.cursor = 'pointer';

                    highlightRouteOnHover(routeIndex);

                    const panel = document.getElementById('routeDetailsPanel');
                    if (panel.classList.contains('active')) {
                        showRouteDetails(routeIndex);
                    }
                }
            };

            const onHoverEnd = () => {
                if (visible.__orig) {
                    visible.setOptions({
                        strokeWeight: visible.__orig.strokeWeight,
                        strokeOpacity: visible.__orig.strokeOpacity,
                        zIndex: visible.__orig.zIndex
                    });
                }

                if (visible.__glow) {
                    visible.__glow.setMap(null);
                    visible.__glow = null;
                }

                const mapDiv = map.getDiv && map.getDiv();
                if (mapDiv) mapDiv.style.cursor = '';

                const panel = document.getElementById('routeDetailsPanel');
                if (!panel.classList.contains('active') && !editMode) {
                    unhighlightAllRoutes();
                }
            };

            const onClick = (e) => {
                if (e && e.stop) e.stop();
                requestAnimationFrame(() => showRouteDetails(routeIndex));
            };

            // Attach events
            google.maps.event.addListener(hitArea, 'mouseover', onHoverStart);
            google.maps.event.addListener(hitArea, 'mouseout', onHoverEnd);
            google.maps.event.addListener(hitArea, 'click', onClick);

            const layer = {
                id: `route-${routeIndex}`,
                visible,
                hitArea,
                color,
                index: routeIndex
            };

            routeLayers.push(layer);
            return layer;
        }

        /**
         * Adapt all hit areas when zoom changes
         */
        function adaptAllHitAreasToZoom() {
            routeLayers.forEach(layer => {
                const newWeight = computeAdaptiveHitWeight(40);
                layer.hitArea.setOptions({ strokeWeight: newWeight });
            });
        }

        // Add zoom listener
        let _zoomDebounce;
        if (map && map.addListener) {
            map.addListener('zoom_changed', () => {
                clearTimeout(_zoomDebounce);
                _zoomDebounce = setTimeout(adaptAllHitAreasToZoom, 120);
            });
        }

        function createSequentialRoute(route, color, routeIndex) {
            if (route.assigned_users.length === 0) return;

            // Create waypoints array for all user locations
            const waypoints = [];

            // Add all user locations as waypoints
            route.assigned_users.forEach(user => {
                waypoints.push({
                    location: {lat: parseFloat(user.lat), lng: parseFloat(user.lng)},
                    stopover: true
                });
            });

            // Create enhanced route line with outline
            const directionsRenderer = new google.maps.DirectionsRenderer({
                suppressMarkers: true,
                preserveViewport: true,
                polylineOptions: {
                    strokeColor: color,
                    strokeOpacity: 0.7, // Glass effect
                    strokeWeight: 5,
                    zIndex: 300
                },
            });
            directionsRenderer.setMap(map);

            // Build the route: Office -> All Users (office-centric route)
            const request = {
                origin: OFFICE_LOCATION,
                destination: waypoints[waypoints.length - 1].location,
                waypoints: waypoints.slice(0, -1),
                optimizeWaypoints: true,
                travelMode: google.maps.TravelMode.DRIVING,
                avoidHighways: false,
                avoidTolls: false
            };

            directionsService.route(request, (response, status) => {
                if (status === "OK") {
                    directionsRenderer.setDirections(response);

                    // Create glassmorphic route with enhanced hover
                    const path = response.routes[0].overview_path;
                    const layer = createGlassmorphicRoute(path, color, routeIndex, {
                        baseWeight: 5,
                        hitBase: 40,
                        zIndex: 300
                    });

                    // Store in route renderers
                    const routeItem = {
                        renderer: directionsRenderer,
                        routePolyline: layer.visible,
                        interactionPolyline: layer.hitArea,
                        color: color,
                        index: routeIndex
                    };

                    routeRenderers.push(routeItem);
                } else {
                    console.warn(`Office-to-users route failed for Route ${routeIndex + 1}:`, status);
                    createFallbackOfficeRoute(route, color, routeIndex);
                }
            });
        }

        function createFallbackOfficeRoute(route, color, routeIndex) {
            // Create simple polyline route as fallback: Office -> Users
            const routePath = [
                OFFICE_LOCATION // Start at office
            ];

            // Add all user locations
            route.assigned_users.forEach(user => {
                routePath.push({lat: parseFloat(user.lat), lng: parseFloat(user.lng)});
            });

            // Use glassmorphic route creation
            const layer = createGlassmorphicRoute(routePath, color, routeIndex, {
                baseWeight: 4,
                hitBase: 40,
                zIndex: 250
            });

            // Add directional arrows to visible polyline
            layer.visible.setOptions({
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                        scale: 3,
                        fillColor: color,
                        fillOpacity: 0.8,
                        strokeColor: '#ffffff',
                        strokeWeight: 1
                    },
                    offset: '100%',
                    repeat: '30px'
                }]
            });

            // Store route item
            const routeItem = {
                renderer: null,
                routePolyline: layer.visible,
                interactionPolyline: layer.hitArea,
                fallbackPolyline: layer.visible,
                color: color,
                index: routeIndex
            };

            routeRenderers.push(routeItem);
        }

        function createOptimalPath(route, color) {
            if (route.assigned_users.length < 2) return;

            // Create TSP-like optimal path through all users
            const points = [
                {lat: parseFloat(route.latitude), lng: parseFloat(route.longitude), type: 'driver'},
                ...route.assigned_users.map(user => ({
                    lat: parseFloat(user.lat),
                    lng: parseFloat(user.lng),
                    type: 'user',
                    id: user.user_id
                }))
            ];

            // Simple nearest neighbor algorithm for demonstration
            const path = [points[0]]; // Start with driver
            const remaining = points.slice(1);

            while (remaining.length > 0) {
                const current = path[path.length - 1];
                let nearest = remaining[0];
                let nearestIndex = 0;
                let minDistance = haversineDistance(current.lat, current.lng, nearest.lat, nearest.lng);

                for (let i = 1; i < remaining.length; i++) {
                    const distance = haversineDistance(current.lat, current.lng, remaining[i].lat, remaining[i].lng);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = remaining[i];
                        nearestIndex = i;
                    }
                }

                path.push(nearest);
                remaining.splice(nearestIndex, 1);
            }

            // Add office as final destination
            path.push({lat: OFFICE_LOCATION.lat, lng: OFFICE_LOCATION.lng, type: 'office'});

            const optimalPath = new google.maps.Polyline({
                path: path.map(p => ({lat: p.lat, lng: p.lng})),
                geodesic: true,
                strokeColor: color,
                strokeOpacity: 0.9,
                strokeWeight: 6,
                zIndex: 400,
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                        scale: 3,
                        fillColor: color,
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 1
                    },
                    offset: '100%',
                    repeat: '50px'
                }]
            });

            optimalPath.setMap(map);
            optimalPaths.push(optimalPath);
        }

        function createHeatmap(data) {
            heatmap = new google.maps.visualization.HeatmapLayer({
                data: data,
                map: map,
                radius: 30,
                opacity: 0.8,
                gradient: [
                    'rgba(0, 255, 255, 0)',
                    'rgba(0, 255, 255, 1)',
                    'rgba(0, 191, 255, 1)',
                    'rgba(0, 127, 255, 1)',
                    'rgba(0, 63, 255, 1)',
                    'rgba(0, 0, 255, 1)',
                    'rgba(0, 0, 223, 1)',
                    'rgba(0, 0, 191, 1)',
                    'rgba(0, 0, 159, 1)',
                    'rgba(0, 0, 127, 1)',
                    'rgba(63, 0, 91, 1)',
                    'rgba(127, 0, 63, 1)',
                    'rgba(191, 0, 31, 1)',
                    'rgba(255, 0, 0, 1)'
                ]
            });
        }

        function updateStats() {
            const totalRoutes = allRoutes.length;
            const totalUsers = allRoutes.reduce((sum, route) => sum + route.assigned_users.length, 0);
            const totalDrivers = allRoutes.length;

            const utilizations = allRoutes.map(route => route.assigned_users.length / getVehicleCapacity(route));
            const avgUtilization = utilizations.length ?
                (utilizations.reduce((a, b) => a + b, 0) / utilizations.length * 100).toFixed(1) : 0;

            document.getElementById('totalRoutes').textContent = totalRoutes;
            document.getElementById('totalUsers').textContent = totalUsers;
            document.getElementById('avgUtilization').textContent = avgUtilization + '%';
            document.getElementById('totalDrivers').textContent = totalDrivers;
        }

        function updateAnalytics() {
            const totalUsers = allRoutes.reduce((sum, route) => sum + route.assigned_users.length, 0);
            const totalCapacity = allRoutes.reduce((sum, route) => sum + getVehicleCapacity(route), 0);

            // Performance metrics
            const assignmentRate = totalUsers && totalCapacity ? Math.min(100, (totalUsers / totalCapacity * 100)).toFixed(1) : 0;
            const capacityUtilization = totalCapacity ? (totalUsers / totalCapacity * 100).toFixed(1) : 0;

            // Distance calculations
            let totalDistance = 0;
            let connectionCount = 0;
            allRoutes.forEach(route => {
                route.assigned_users.forEach(user => {
                    totalDistance += haversineDistance(route.latitude, route.longitude, user.lat, user.lng);
                    connectionCount++;
                });
            });
            const avgDistance = connectionCount ? (totalDistance / connectionCount).toFixed(1) : 0;

            // Efficiency score (0-10)
            const efficiencyScore = calculateEfficiencyScore(allRoutes).toFixed(1);

            // Route quality breakdown
            const highEfficiency = allRoutes.filter(r => (r.assigned_users.length / r.vehicle_type) >= 0.8).length;
            const mediumEfficiency = allRoutes.filter(r => {
                const util = r.assigned_users.length / r.vehicle_type;
                return util >= 0.5 && util < 0.8;
            }).length;
            const lowEfficiency = allRoutes.filter(r => (r.assigned_users.length / r.vehicle_type) < 0.5).length;

            // Update UI
            document.getElementById('assignmentRate').textContent = assignmentRate + '%';
            document.getElementById('capacityUtilization').textContent = capacityUtilization + '%';
            document.getElementById('avgDistance').textContent = avgDistance + ' km';
            document.getElementById('efficiencyScore').textContent = efficiencyScore + '/10';
            document.getElementById('highEfficiencyRoutes').textContent = highEfficiency;
            document.getElementById('mediumEfficiencyRoutes').textContent = mediumEfficiency;
            document.getElementById('lowEfficiencyRoutes').textContent = lowEfficiency;

            // Generate alerts
            generateSystemAlerts({
                assignmentRate: parseFloat(assignmentRate),
                capacityUtilization: parseFloat(capacityUtilization),
                avgDistance: parseFloat(avgDistance),
                efficiencyScore: parseFloat(efficiencyScore),
                lowEfficiency
            });
        }

        function calculateEfficiencyScore(routes) {
            if (routes.length === 0) return 0;

            let score = 0;
            let factors = 0;

            // Factor 1: Utilization (40% weight)
            const avgUtilization = routes.reduce((sum, r) => sum + (r.assigned_users.length / r.vehicle_type), 0) / routes.length;
            score += Math.min(avgUtilization * 10, 4);
            factors += 4;

            // Factor 2: Distance efficiency (30% weight)
            let totalDistance = 0;
            let connections = 0;
            routes.forEach(route => {
                route.assigned_users.forEach(user => {
                    totalDistance += haversineDistance(route.latitude, route.longitude, user.lat, user.lng);
                    connections++;
                });
            });
            const avgDistance = connections ? totalDistance / connections : 0;
            const distanceScore = Math.max(0, 3 - (avgDistance / 5) * 3); // 3 points max, penalty for distance > 5km
            score += distanceScore;
            factors += 3;

            // Factor 3: Balance (30% weight)
            const utilizations = routes.map(r => r.assigned_users.length / r.vehicle_type);
            const stdDev = Math.sqrt(utilizations.reduce((sum, u) => sum + Math.pow(u - avgUtilization, 2), 0) / utilizations.length);
            const balanceScore = Math.max(0, 3 - stdDev * 6); // 3 points max, penalty for high variance
            score += balanceScore;
            factors += 3;

            return score;
        }

        function generateSystemAlerts(metrics) {
            const container = document.getElementById('alertsContainer');
            container.innerHTML = '';

            const alerts = [];

            if (metrics.capacityUtilization < 60) {
                alerts.push({
                    type: 'warning',
                    icon: 'exclamation-triangle',
                    message: `Low capacity utilization (${metrics.capacityUtilization}%) - Consider optimizing routes`
                });
            }

            if (metrics.avgDistance > 8) {
                alerts.push({
                    type: 'error',
                    icon: 'route',
                    message: `High average distance (${metrics.avgDistance} km) - Routes may be inefficient`
                });
            }

            if (metrics.lowEfficiency > allRoutes.length * 0.3) {
                alerts.push({
                    type: 'warning',
                    icon: 'chart-line',
                    message: `${metrics.lowEfficiency} routes have low efficiency - Review assignments`
                });
            }

            if (metrics.efficiencyScore >= 8) {
                alerts.push({
                    type: 'success',
                    icon: 'thumbs-up',
                    message: `Excellent efficiency score (${metrics.efficiencyScore}/10)!`
                });
            }

            if (alerts.length === 0) {
                alerts.push({
                    type: 'success',
                    icon: 'thumbs-up',
                    message: 'All systems operating efficiently'
                });
            }

            alerts.forEach(alert => {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${alert.type}`;
                alertDiv.innerHTML = `<i class="fas fa-${alert.icon}"></i> ${alert.message}`;
                container.appendChild(alertDiv);
            });
        }

        // Utility Functions
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the earth in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Helper function to calculate distance between two points using Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            return haversineDistance(lat1, lon1, lat2, lon2);
        }


        function adjustBrightness(color, amount) {
            let usePound = false;
            if (color[0] == "#") {
                color = color.slice(1);
                usePound = true;
            }
            const num = parseInt(color, 16);
            let r = (num >> 16) + amount;
            if (r > 255) r = 255;
            else if (r < 0) r = 0;
            let b = ((num >> 8) & 0x00FF) + amount;
            if (b > 255) b = 255;
            else if (b < 0) b = 0;
            let g = (num & 0x0000FF) + amount;
            if (g > 255) g = 255;
            else if (g < 0) g = 0;
            return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');
        }

        function clearMap() {
            // Clear markers
            Object.values(markers).forEach(group => {
                if (Array.isArray(group)) {
                    group.forEach(item => {
                        if (item && item.marker) item.marker.setMap(null);
                        if (item && item.infoWindow) item.infoWindow.close();
                    });
                } else if (group && group.marker) { // For office marker
                    group.marker.setMap(null);
                }
            });
            markers = {office: null, drivers: [], users: [], routes: []}; // Reset

            // Clear route renderers efficiently
            routeRenderers.forEach(item => {
                if (item.renderer) item.renderer.setMap(null);
                if (item.routePolyline) item.routePolyline.setMap(null);
                if (item.fallbackPolyline) item.fallbackPolyline.setMap(null);
                if (item._outline) item._outline.setMap(null);
                if (item.interactionPolyline) item.interactionPolyline.setMap(null);
            });
            routeRenderers = [];

            // Clear optimal paths
            optimalPaths.forEach(path => path.setMap(null));
            optimalPaths = [];

            // Clear heatmap
            if (heatmap) {
                heatmap.setMap(null);
                heatmap = null;
            }

            // Clear spotlight mask
            if (spotlightMask) {
                spotlightMask.setMap(null);
                spotlightMask = null;
            }
        }

        function closeAllInfoWindows() {
            // close for drivers and users
            [...(markers.drivers || []), ...(markers.users || [])].forEach(item => {
                if (item && item.infoWindow) item.infoWindow.close();
            });

            if (markers.office && markers.office.infoWindow) {
                markers.office.infoWindow.close();
            }
        }

        function showAlert(type, message) {
            const container = document.getElementById('alertsContainer');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.innerHTML = `<i class="fas fa-${type === 'error' ? 'exclamation-circle' : type === 'warning' ? 'exclamation-triangle' : 'check-circle'}"></i> ${message}`;
            container.appendChild(alertDiv);
        }

        // Track mouse position for contextual placement
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function showRouteInfo(route, index, event) {
            const popup = document.getElementById('routeInfoPopup');
            const utilization = (route.assigned_users.length / getVehicleCapacity(route) * 100).toFixed(1);
            const routeColor = colorForRoute(index, allRoutes.length);

            // Generate sparkline data (simulated occupancy trend)
            const sparklineData = generateSparklineData(route);
            const sparklinePath = createSparklinePath(sparklineData);

            // Calculate efficiency rating
            const efficiencyEmoji = utilization >= 80 ? 'ðŸŸ¢' : utilization >= 50 ? 'ðŸŸ¡' : 'ðŸ”´';
            const efficiencyText = utilization >= 80 ? 'High' : utilization >= 50 ? 'Medium' : 'Low';

            const content = `
                <div class="route-inspector-card">
                    <div class="inspector-header">
                        <div class="inspector-title">
                            <span style="font-size: 14px;">ðŸš—</span>
                            Route ${index + 1}
                            <span class="inspector-badge">${route.assigned_users.length}/${getVehicleCapacity(route)}</span>
                        </div>
                    </div>
                    <div class="inspector-body">
                        <div class="inspector-metrics">
                            <div class="metric-compact">
                                <div class="metric-compact-value">${utilization}%</div>
                                <div class="metric-compact-label">Capacity</div>
                            </div>
                            <div class="metric-compact">
                                <div class="metric-compact-value">${efficiencyEmoji}</div>
                                <div class="metric-compact-label">${efficiencyText}</div>
                            </div>
                        </div>

                        <div class="sparkline-container">
                            <div class="sparkline-label">Occupancy Trend</div>
                            <svg class="sparkline" viewBox="0 0 100 30" preserveAspectRatio="none">
                                <path d="${sparklinePath}" fill="none" stroke="${routeColor}" stroke-width="2" opacity="0.8"/>
                                <path d="${sparklinePath} L 100,30 L 0,30 Z" fill="${routeColor}" opacity="0.2"/>
                            </svg>
                        </div>

                        <div style="margin-top: var(--space-sm);">
                            <div style="font-size: 10px; color: var(--gray-500); margin-bottom: 2px;">Capacity Usage</div>
                            <div class="capacity-bar">
                                <div class="capacity-fill" style="width: ${utilization}%; background: ${routeColor};"></div>
                            </div>
                        </div>
                    </div>
                    <div class="inspector-footer">
                        ðŸ’¡ Click route for full details
                    </div>
                </div>
            `;

            document.getElementById('routeInfoContent').innerHTML = content;

            // Position near cursor with offset
            const offsetX = 20;
            const offsetY = 20;
            const maxX = window.innerWidth - 300;
            const maxY = window.innerHeight - 250;

            popup.style.left = Math.min(mouseX + offsetX, maxX) + 'px';
            popup.style.top = Math.min(mouseY + offsetY, maxY) + 'px';
            popup.classList.add('visible');
        }

        function hideRouteInfo() {
            const popup = document.getElementById('routeInfoPopup');
            popup.classList.remove('visible');
        }

        // Generate simulated sparkline data for occupancy trend
        function generateSparklineData(route) {
            const points = 12; // 12 data points for trend
            const utilization = route.assigned_users.length / getVehicleCapacity(route);
            const data = [];

            for (let i = 0; i < points; i++) {
                // Simulate variation around current utilization
                const variance = (Math.random() - 0.5) * 0.3;
                const value = Math.max(0, Math.min(1, utilization + variance));
                data.push(value);
            }

            return data;
        }

        // Create SVG path for sparkline
        function createSparklinePath(data) {
            const width = 100;
            const height = 30;
            const step = width / (data.length - 1);

            let path = `M 0,${height - data[0] * height}`;

            for (let i = 1; i < data.length; i++) {
                const x = i * step;
                const y = height - data[i] * height;
                path += ` L ${x},${y}`;
            }

            return path;
        }

        // Debounced search for better performance
        let searchTimeout = null;
        function handleSearch() {
            if (searchTimeout) clearTimeout(searchTimeout);

            searchTimeout = setTimeout(() => {
                const query = document.getElementById("searchInput").value.toLowerCase().trim();

                if (!query) {
                    loadRouteData();
                    return;
                }

                fetch(API_URL)
                    .then(res => res.json())
                    .then(responseData => {
                        // Handle unified response format
                        let routes = [];
                        if (responseData && responseData.data && Array.isArray(responseData.data)) {
                            routes = responseData.data;
                        } else if (Array.isArray(responseData)) {
                            routes = responseData;
                        } else {
                            routes = responseData.data || [];
                        }

                        const filtered = routes.filter(route =>
                            route.driver_id.toLowerCase().includes(query) ||
                            route.vehicle_id.toLowerCase().includes(query) ||
                            route.assigned_users.some(user =>
                                user.user_id.toLowerCase().includes(query) ||
                                (user.first_name && user.first_name.toLowerCase().includes(query)) ||
                                (user.email && user.email.toLowerCase().includes(query))
                            )
                        );
                        allRoutes = filtered;
                        renderMap();
                        updateStats();
                    })
                    .catch(error => {
                        console.error('Search error:', error);
                        showAlert('error', 'Search failed. Please try again.');
                    });
            }, 300); // 300ms debounce
        }

        function filterCluster() {
            const selectedValue = document.getElementById("clusterSelect").value;
            if (selectedValue === "all") {
                loadRouteData(); // Reload all data
            } else {
                // Reload original data to ensure we have the correct route
                fetch(API_URL)
                    .then(res => res.json())
                    .then(responseData => {
                        // Handle unified response format
                        let routes = [];
                        if (responseData && responseData.data && Array.isArray(responseData.data)) {
                            routes = responseData.data;
                        } else if (Array.isArray(responseData)) {
                            routes = responseData;
                        } else {
                            routes = responseData.data || [];
                        }

                        if (routes && routes[parseInt(selectedValue)]) {
                            allRoutes = [routes[parseInt(selectedValue)]];
                            renderMap();
                            updateStats(); // Update stats for the single route
                        } else {
                            showAlert('error', 'Selected route not found.');
                        }
                    })
                    .catch(error => {
                        console.error('Error reloading data for cluster filter:', error);
                        showAlert('error', 'Failed to refresh data for filtering.');
                    });
            }
        }

        function filterByUtilization() {
            const minUtilizationPercent = parseInt(document.getElementById("utilizationRange").value);
            const minUtilization = minUtilizationPercent / 100;
            document.getElementById("utilizationValue").textContent = `${minUtilizationPercent}%`;

            // Reload original data to filter from
            fetch(API_URL)
                .then(res => res.json())
                .then(responseData => {
                    // Handle unified response format
                    let routes = [];
                    if (responseData && responseData.data && Array.isArray(responseData.data)) {
                        routes = responseData.data;
                    } else if (Array.isArray(responseData)) {
                        routes = responseData;
                    } else {
                        routes = responseData.data || [];
                    }

                    const filtered = routes.filter(route => {
                        // Use capacity instead of vehicle_type
                        const capacity = route.capacity || getVehicleCapacity(route) || 4;
                        const utilization = route.assigned_users.length / capacity;
                        return utilization >= minUtilization;
                    });
                    allRoutes = filtered;
                    renderMap();
                    updateStats(); // Update stats based on filtered data
                })
                .catch(error => {
                    console.error('Error reloading data for utilization filter:', error);
                    showAlert('error', 'Failed to refresh data for filtering.');
                });
        }

        function showAllRoutes() {
            // Remove all highlights
            document.querySelectorAll('.cluster-color').forEach(el => el.classList.remove('active'));

            // Highlight "All" button
            const allButton = document.querySelector('.cluster-color:first-child');
            if (allButton) {
                allButton.classList.add('active');
            }

            // Reload all routes
            fetch(API_URL)
                .then(res => res.json())
                .then(responseData => {
                    // Handle unified response format
                    let routes = [];
                    if (responseData && responseData.data && Array.isArray(responseData.data)) {
                        routes = responseData.data;
                        unassignedUsers = responseData.unassignedUsers || [];
                        unassignedDrivers = responseData.unassignedDrivers || [];
                    } else if (responseData && responseData.all_modes && responseData.modes) {
                        // Handle all_modes format
                        const firstMode = Object.values(responseData.modes)[0];
                        routes = firstMode?.data || [];
                        unassignedUsers = [];
                        unassignedDrivers = [];
                    } else if (Array.isArray(responseData)) {
                        routes = responseData;
                        unassignedUsers = [];
                        unassignedDrivers = [];
                    } else {
                        routes = responseData.data || [];
                        unassignedUsers = [];
                        unassignedDrivers = [];
                    }

                    // Normalize user coordinate data
                    routes = routes.map(route => ({
                        ...route,
                        assigned_users: route.assigned_users.map(user => normalizeUserData(user))
                    }));
                    unassignedUsers = unassignedUsers.map(user => normalizeUserData(user));

                    allRoutes = routes;
                    renderMap();
                    updateStats();
                    // Also update dropdown
                    document.getElementById('clusterSelect').value = 'all';
                })
                .catch(error => {
                    console.error('Error reloading all routes:', error);
                    showAlert('error', 'Failed to load all routes.');
                });
        }

        function highlightRoute(index) {
            // Remove all highlights
            document.querySelectorAll('.cluster-color').forEach(el => el.classList.remove('active'));

            // Highlight selected (add 1 to account for "All" button being first)
            const highlightedElement = document.querySelector(`.cluster-color:nth-child(${index + 2})`);
            if (highlightedElement) {
                highlightedElement.classList.add('active');
            }

            // Filter to show only this route
            fetch(API_URL)
                .then(res => res.json())
                .then(routes => {
                    // Handle both array and all_modes format
                    let routesArray = routes;
                    if (routes && routes.all_modes && routes.modes) {
                        // Get first available mode's data
                        const firstMode = Object.values(routes.modes)[0];
                        routesArray = firstMode?.data || [];
                    } else if (!Array.isArray(routes)) {
                        routesArray = routes.data || [];
                    }

                    if (routesArray && routesArray[index]) {
                        allRoutes = [routesArray[index]];
                        renderMap();
                        updateStats();

                        // Focus map on this route
                        const route = allRoutes[0];
                        if (route.assigned_users && route.assigned_users.length > 0) {
                            const bounds = new google.maps.LatLngBounds();
                            bounds.extend(OFFICE_LOCATION);
                            route.assigned_users.forEach(user => {
                                bounds.extend(new google.maps.LatLng(parseFloat(user.lat), parseFloat(user.lng)));
                            });
                            map.fitBounds(bounds);
                        }
                    } else {
                        showAlert('error', 'Selected route not found.');
                    }
                })
                .catch(error => {
                    console.error('Error reloading data for highlighting:', error);
                    showAlert('error', 'Failed to refresh data for highlighting.');
                });
        }

        // Toggle Functions
        function toggleUsers() {
            displayState.users = !displayState.users;
            renderMap();
            updateDisplayButtons();
        }

        function toggleDrivers() {
            displayState.drivers = !displayState.drivers;
            renderMap();
            updateDisplayButtons();
        }

        function toggleRouteLines() {
            displayState.routeLines = !displayState.routeLines;
            renderMap();
            updateDisplayButtons();
        }

        function toggleHeatmap() {
            displayState.heatmap = !displayState.heatmap;
            renderMap();
            updateDisplayButtons();
        }

        function showOptimalPaths() {
            displayState.optimalPaths = !displayState.optimalPaths;
            renderMap();
            updateDisplayButtons();
        }

        function toggleUserNameDisplay() {
            displayState.showUserNames = !displayState.showUserNames;
            renderMap();
            updateDisplayButtons();

            const btn = document.getElementById('toggleUserNameBtn');
            if (displayState.showUserNames) {
                btn.innerHTML = '<i class="fas fa-user-circle"></i> Show Icons';
            } else {
                btn.innerHTML = '<i class="fas fa-id-badge"></i> Show User Names';
            }
        }

        function updateDisplayButtons() {
            const buttons = [
                {id: 'toggleUsersBtn', state: displayState.users},
                {id: 'toggleDriversBtn', state: displayState.drivers},
                {id: 'toggleRouteLinesBtn', state: displayState.routeLines},
                {id: 'toggleHeatmapBtn', state: displayState.heatmap},
                {id: 'showOptimalBtn', state: displayState.optimalPaths},
                {id: 'toggleUserNameBtn', state: displayState.showUserNames}
            ];

            buttons.forEach(({id, state}) => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (state) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
        }

        // Map Control Functions
        function centerOnOffice() {
            map.setCenter(OFFICE_LOCATION);
            map.setZoom(12);
        }

        function fitAllRoutes() {
            if (allRoutes.length === 0) return;

            const bounds = new google.maps.LatLngBounds();
            bounds.extend(OFFICE_LOCATION);

            allRoutes.forEach(route => {
                bounds.extend(new google.maps.LatLng(parseFloat(route.latitude), parseFloat(route.longitude)));
                route.assigned_users.forEach(user => {
                    bounds.extend(new google.maps.LatLng(parseFloat(user.lat), parseFloat(user.lng)));
                });
            });

            map.fitBounds(bounds);
        }

        function refreshData() {
            showAlert('success', 'Refreshing route data...');
            loadRouteData();
        }

        function togglePlaceNames() {
            showPlaceNames = !showPlaceNames;
            const btn = document.getElementById('togglePlaceNamesBtn');

            if (showPlaceNames) {
                map.setOptions({styles: originalMapStyles});
                btn.classList.add('active');
                btn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Hide Places';
            } else {
                map.setOptions({styles: cleanMapStyles});
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fas fa-map-marker-alt"></i> Place Names';
            }
        }

        function toggleMiniMaps() {
            miniMapsVisible = !miniMapsVisible;
            const panel = document.getElementById('miniMapsPanel');
            const btn = document.getElementById('toggleMiniMapsBtn');

            if (miniMapsVisible) {
                panel.classList.add('active');
                btn.classList.add('active');
                generateMiniMaps();
            } else {
                panel.classList.remove('active');
                btn.classList.remove('active');
            }
        }

        function generateMiniMaps() {
            const container = document.getElementById('miniMapsContainer');
            container.innerHTML = '<p style="color: #94a3b8; font-size: 13px; text-align: center;">Mini-maps feature coming soon!</p>';
        }

        // Export Functions
        function exportAnalytics() {
            const csvData = allRoutes.map((route, index) => ({
                route_id: index + 1,
                driver_id: route.driver_id,
                vehicle_id: route.vehicle_id,
                capacity: getVehicleCapacity(route),
                assigned_users: route.assigned_users.length,
                utilization_percent: ((route.assigned_users.length / getVehicleCapacity(route)) * 100).toFixed(2),
                efficiency_rating: route.assigned_users.length / getVehicleCapacity(route) >= 0.8 ? 'High' :
                    route.assigned_users.length / getVehicleCapacity(route) >= 0.5 ? 'Medium' : 'Low',
                driver_lat: route.latitude,
                driver_lng: route.longitude
            }));

            if (csvData.length === 0) {
                showAlert('warning', 'No data available to export.');
                return;
            }

            const csv = [
                Object.keys(csvData[0]).join(','),
                ...csvData.map(row => Object.values(row).join(','))
            ].join('\n');

            const blob = new Blob([csv], {type: 'text/csv'});
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `routeflow-analytics-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            window.URL.revokeObjectURL(url);

            showAlert('success', 'Analytics data exported successfully!');
        }

        function generateReport() {
            const report = {
                generated_at: new Date().toISOString(),
                platform: "RouteFlow - Smart Driver Assignment Platform",
                summary: {
                    total_routes: allRoutes.length,
                    total_users: allRoutes.reduce((sum, r) => sum + r.assigned_users.length, 0),
                    total_capacity: allRoutes.reduce((sum, r) => sum + r.vehicle_type, 0),
                    average_utilization: allRoutes.length > 0 ? (allRoutes.reduce((sum, r) => sum + (r.assigned_users.length / r.vehicle_type), 0) / allRoutes.length * 100).toFixed(2) : 0,
                    efficiency_score: calculateEfficiencyScore(allRoutes).toFixed(2)
                },
                route_details: allRoutes.map((route, index) => ({
                    route_id: index + 1,
                    driver_id: route.driver_id,
                    vehicle_info: {
                        vehicle_id: route.vehicle_id,
                        capacity: getVehicleCapacity(route)
                    },
                    assignment_info: {
                        users_assigned: route.assigned_users.length,
                        utilization_percent: ((route.assigned_users.length / getVehicleCapacity(route)) * 100).toFixed(2),
                        efficiency_rating: route.assigned_users.length / getVehicleCapacity(route) >= 0.8 ? 'High' :
                            route.assigned_users.length / getVehicleCapacity(route) >= 0.5 ? 'Medium' : 'Low'
                    },
                    location: {
                        latitude: route.latitude,
                        longitude: route.longitude
                    },
                    assigned_users: route.assigned_users
                }))
            };

            if (allRoutes.length === 0) {
                showAlert('warning', 'No data available to generate report.');
                return;
            }

            const blob = new Blob([JSON.stringify(report, null, 2)], {type: 'application/json'});
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `routeflow-report-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            window.URL.revokeObjectURL(url);

            showAlert('success', 'Comprehensive report generated successfully!');
        }

        function exportMapImage() {
            // Note: This would require html2canvas library for actual implementation
            // For now, instructing the user to use browser's screenshot feature.
            showAlert('warning', 'Map capture feature requires external libraries. Please use your browser\'s screenshot tool.');
        }

        // ============================================================================
        // EDIT MODE FUNCTIONS
        // ============================================================================
        function initializeEditModeToggle() {
            const editBtn = document.getElementById('editRoutesBtn');
            if (editBtn) {
                editBtn.addEventListener('click', toggleEditMode);
            }
        }

        function toggleEditMode() {
            editMode = !editMode;
            const mapHeader = document.getElementById('mapHeader');
            const editorPanel = document.getElementById('routeEditorPanel');
            const legend = document.querySelector('.floating-legend');

            if (editMode) {
                mapHeader.classList.add('edit-mode');
                editorPanel.classList.add('active');
                legend.classList.add('hidden-in-edit');

                // Disable spotlight effect in edit mode
                if (spotlightMask) {
                    spotlightMask.setMap(null);
                    spotlightMask = null;
                }

                // Make user markers draggable
                enableMarkerDragging();

                // Load routes into editor
                prepareEditorData(); // Prepare data before loading into editor
                loadRoutesIntoEditor();


                // Record initial state for undo/redo
                originalRoutesSnapshot = JSON.parse(JSON.stringify(allRoutes));
                editorHistory = []; // Clear history on entering edit mode
                historyIndex = -1;
                recordHistoryState('Entered Edit Mode', 'enter');

            } else {
                mapHeader.classList.remove('edit-mode');
                editorPanel.classList.remove('active');
                legend.classList.remove('hidden-in-edit');

                // Re-enable spotlight if needed (will be recreated on hover)

                // Disable marker dragging with force flag to ensure cleanup
                disableMarkerDragging(true);

                // Clear editor state
                unassignedUsers = [];
                draggedUser = null;
                draggedFromRouteIndex = null;
                dragOverRouteIndex = null;
                dirtyRoutes.clear();
                originalRoutesSnapshot = null;
                editorHistory = [];
                historyIndex = -1;
                pendingChanges = {}; // Clear pending changes

                // Re-render map to ensure correct state (especially if changes were made)
                loadRouteData(); // Reload data to reset any unsaved changes
            }
            updateMapHeaderControls(); // Update edit button appearance
            
            // Trigger map resize after panel animation
            triggerMapResizeDebounced();
        }

        function closeRouteEditor() {
            if (!editMode) return;

            // If there are pending changes, confirm before discarding
            if (pendingChanges && Object.keys(pendingChanges).length > 0) {
                const discard = confirm('You have unsaved edits. Discard changes and exit edit mode?');
                if (!discard) return; // stay in editor
                // If user confirms, clear pendingChanges
                pendingChanges = {};
            }

            // Toggle edit mode directly (safer than simulating a click)
            toggleEditMode();
        }

        function switchEditorTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.editor-tab').forEach(tab => {
                const isActive = tab.textContent.includes(tabName.charAt(0).toUpperCase() + tabName.slice(1));
                tab.classList.toggle('active', isActive);
            });

            // Show corresponding content
            document.querySelectorAll('.editor-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`editorTab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`).style.display = 'block';

            // Refresh content based on tab
            if (tabName === 'history') {
                renderHistoryTimeline();
            } else if (tabName === 'simulator') {
                updateSimulator();
            }
        }

        function enableMarkerDragging() {
            if (!editMode) return;

            // Make user markers draggable
            markers.users.forEach((markerInfo) => {
                const marker = markerInfo.marker;
                if (marker) {
                    marker.setDraggable(true);

                    // Store original position
                    marker.originalPosition = marker.getPosition();

                    // Add drag start listener
                    const dragStartListener = google.maps.event.addListener(marker, 'dragstart', function (event) {
                        draggedMarker = marker;
                        draggedUserData = marker.userData;

                        // Find which route this user belongs to
                        draggedFromRouteIndex = null;
                        for (let i = 0; i < allRoutes.length; i++) {
                            const routeUsers = allRoutes[i].assigned_users;
                            const userIndex = routeUsers.findIndex(u => u.user_id === draggedUserData.user_id);
                            if (userIndex !== -1) {
                                draggedFromRouteIndex = i;
                                break;
                            }
                        }

                        // Visual feedback
                        marker.setOptions({
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 15,
                                fillColor: '#FF6B35', // Orange color for dragging
                                fillOpacity: 0.9,
                                strokeColor: '#FFFFFF',
                                strokeWeight: 4
                            },
                            zIndex: 9999 // Bring to front
                        });
                        highlightDropZones(true); // Highlight potential drop targets
                    });
                    marker.__dragStartListener = dragStartListener; // Store listener for removal

                    // Add drag listener for visual feedback
                    const dragListener = google.maps.event.addListener(marker, 'drag', function (event) {
                        const currentPosition = event.latLng;

                        // Find nearest route for highlighting
                        let nearestRoute = findNearestRoute(currentPosition.lat(), currentPosition.lng());

                        if (nearestRoute !== dragOverRouteIndex) {
                            unhighlightRoute(dragOverRouteIndex); // Unhighlight previous
                            highlightRoute(nearestRoute);       // Highlight new
                            dragOverRouteIndex = nearestRoute;
                        }
                    });
                    marker.__dragListener = dragListener;

                    // Add drag end listener
                    const dragEndListener = google.maps.event.addListener(marker, 'dragend', async function (event) {
                        const newPosition = event.latLng;
                        const newLat = newPosition.lat();
                        const newLng = newPosition.lng();

                        // Find nearest route to drop location
                        const dropRouteIndex = findNearestRoute(newLat, newLng);
                        const minDistance = dropRouteIndex !== null ?
                            calculateMinDistanceToRoute(newLat, newLng, allRoutes[dropRouteIndex]) : Infinity;

                        let success = false;
                        // If dropped near a route (within 3km threshold)
                        if (dropRouteIndex !== null && minDistance < 3.0) {
                            success = await handleUserDrop(draggedFromRouteIndex, dropRouteIndex, draggedUserData, newLat, newLng);
                        } else {
                            // Revert to original position if not near any route
                            marker.setPosition(marker.originalPosition);
                            showNotification('Drop location too far from any route', 'warning');
                        }

                        // Reset drag state and visuals
                        draggedMarker = null;
                        draggedUserData = null;
                        draggedFromRouteIndex = null;

                        unhighlightRoute(dragOverRouteIndex); // Unhighlight current
                        dragOverRouteIndex = null;
                        highlightDropZones(false); // Remove drop zone highlights

                        // Restore original marker icon based on route
                        updateMarkerIcon(marker);
                        marker.setOptions({zIndex: markerInfo.zIndex}); // Restore zIndex
                    });
                    marker.__dragEndListener = dragEndListener;
                }
            });
        }

        function disableMarkerDragging(force = false) {
            // Allow forced cleanup even when editMode has already been toggled off
            if (!editMode && !force) return;

            markers.users.forEach(markerInfo => {
                const marker = markerInfo.marker;
                if (marker) {
                    try {
                        marker.setDraggable(false);
                    } catch (e) { /* ignore if marker removed */ }

                    // Reset icon and zIndex
                    updateMarkerIcon(marker);
                    if (markerInfo && markerInfo.zIndex !== undefined) {
                        marker.setOptions({zIndex: markerInfo.zIndex});
                    }

                    // Remove listeners safely
                    if (marker.__dragStartListener) {
                        google.maps.event.removeListener(marker.__dragStartListener);
                        delete marker.__dragStartListener;
                    }
                    if (marker.__dragListener) {
                        google.maps.event.removeListener(marker.__dragListener);
                        delete marker.__dragListener;
                    }
                    if (marker.__dragEndListener) {
                        google.maps.event.removeListener(marker.__dragEndListener);
                        delete marker.__dragEndListener;
                    }
                }
            });

            // reset any drag state
            draggedMarker = null;
            draggedUserData = null;
            draggedFromRouteIndex = null;
            dragOverRouteIndex = null;
        }

        function findNearestRoute(lat, lng) {
            let nearestRoute = null;
            let minDistance = Infinity;

            allRoutes.forEach((route, routeIndex) => {
                const distance = calculateMinDistanceToRoute(lat, lng, route);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestRoute = routeIndex;
                }
            });

            // Return index only if within a reasonable distance (e.g., 5km)
            return minDistance < 5.0 ? nearestRoute : null;
        }

        function calculateMinDistanceToRoute(lat, lng, route) {
            let minDistance = Infinity;

            // Check distance to driver
            const driverDistance = calculateDistance(lat, lng, route.latitude, route.longitude);
            minDistance = Math.min(minDistance, driverDistance);

            // Check distance to all users in route
            route.assigned_users.forEach(user => {
                const userDistance = calculateDistance(lat, lng, user.lat, user.lng);
                minDistance = Math.min(minDistance, userDistance);
            });

            return minDistance;
        }

        async function handleUserDrop(fromRouteIndex, toRouteIndex, userData, newLat, newLng) {
            // Check if moving to a different route
            if (fromRouteIndex === toRouteIndex) {
                // Same route, just update position
                userData.lat = newLat;
                userData.lng = newLng;
                dirtyRoutes.add(toRouteIndex);

                // Recalculate this route
                await recalculateRoute(toRouteIndex);

                renderMap();
                loadRoutesIntoEditor();
                addToHistory('move_user_same_route', {routeIndex: toRouteIndex, userId: userData.user_id});

                return true;
            }

            // Moving to different route - check capacity
            if (allRoutes[toRouteIndex].assigned_users.length >= allRoutes[toRouteIndex].vehicle_type) {
                showNotification(`Route ${toRouteIndex + 1} is at full capacity`, 'error');
                return false;
            }

            // Remove from original route
            const userIndex = allRoutes[fromRouteIndex].assigned_users.findIndex(
                u => u.user_id === userData.user_id
            );
            if (userIndex !== -1) {
                allRoutes[fromRouteIndex].assigned_users.splice(userIndex, 1);
            }

            // Update user position and add to new route
            userData.lat = newLat;
            userData.lng = newLng;
            allRoutes[toRouteIndex].assigned_users.push(userData);

            // Mark both routes as dirty
            dirtyRoutes.add(fromRouteIndex);
            dirtyRoutes.add(toRouteIndex);

            // Recalculate both routes
            await Promise.all([
                recalculateRoute(fromRouteIndex),
                recalculateRoute(toRouteIndex)
            ]);

            // Update UI
            renderMap();
            loadRoutesIntoEditor();

            // Add to history
            addToHistory('move_user_between_routes', {
                fromRoute: fromRouteIndex,
                toRoute: toRouteIndex,
                userId: userData.user_id,
                newPosition: {lat: newLat, lng: newLng}
            });

            showNotification(`Moved user to Route ${toRouteIndex + 1}`, 'success');

            return true;
        }

        async function recalculateRoute(routeIndex) {
            const route = allRoutes[routeIndex];
            if (!route || !route.assigned_users || route.assigned_users.length === 0) {
                return;
            }

            // Recalculate optimal sequence
            const driverPos = {lat: route.latitude, lng: route.longitude};
            const officePos = {lat: OFFICE_LOCATION.lat, lng: OFFICE_LOCATION.lng};

            // Simple nearest-neighbor optimization
            const optimizedUsers = optimizeUserSequence(route.assigned_users, driverPos, officePos);
            route.assigned_users = optimizedUsers;

            // Update route metrics
            route.total_distance = calculateRouteTotalDistance(route, officePos);
            route.utilization = route.assigned_users.length / getVehicleCapacity(route);
        }

        function optimizeUserSequence(users, driverPos, officePos) {
            if (users.length <= 1) return users;

            const optimized = [];
            const remaining = users.slice(); // Fixed: copy array properly
            let currentPos = driverPos;

            while (remaining.length > 0) {
                let nearestIndex = 0;
                let nearestDistance = Infinity;

                remaining.forEach((user, index) => {
                    const distance = calculateDistance(currentPos.lat, currentPos.lng, user.lat, user.lng);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestIndex = index;
                    }
                });

                const nearestUser = remaining.splice(nearestIndex, 1)[0];
                optimized.push(nearestUser);
                currentPos = {lat: nearestUser.lat, lng: nearestUser.lng};
            }

            return optimized;
        }

        function calculateRouteTotalDistance(route, officePos) {
            if (!route.assigned_users || route.assigned_users.length === 0) return 0;

            let total = 0;
            let currentPos = {lat: route.latitude, lng: route.longitude};

            route.assigned_users.forEach(user => {
                total += calculateDistance(currentPos.lat, currentPos.lng, user.lat, user.lng);
                currentPos = {lat: user.lat, lng: user.lng};
            });

            // Add distance to office
            total += calculateDistance(currentPos.lat, currentPos.lng, officePos.lat, officePos.lng);

            return total;
        }

        function highlightDropZones(show) {
            // Highlight all route paths as potential drop zones
            routeRenderers.forEach((renderer, index) => {
                if (show && index !== draggedFromRouteIndex) {
                    // Highlight potential drop zones
                    renderer._outline?.setOptions({strokeWeight: 12, strokeOpacity: 0.4});
                } else {
                    // Reset
                    renderer._outline?.setOptions({strokeWeight: 8, strokeOpacity: 0.3});
                }
            });
        }

        function highlightRoute(routeIndex) {
            if (routeIndex === null || routeIndex === draggedFromRouteIndex) return;

            const renderer = routeRenderers[routeIndex];
            if (renderer && renderer._outline) {
                const color = renderer.color || ROUTE_COLORS[routeIndex % ROUTE_COLORS.length];
                renderer._outline.setOptions({
                    strokeWeight: 14,
                    strokeOpacity: 0.4,
                    strokeColor: '#00FF00' // Bright green for highlighting
                });
            }
        }

        function unhighlightRoute(routeIndex) {
            if (routeIndex === null) return;

            const renderer = routeRenderers[routeIndex];
            if (renderer && renderer._outline) {
                const color = renderer.color || ROUTE_COLORS[routeIndex % ROUTE_COLORS.length];
                renderer._outline.setOptions({
                    strokeWeight: 8,
                    strokeOpacity: 0.3,
                    strokeColor: color
                });
            }
        }

        function updateMarkerIcon(marker) {
            // Find which route this marker belongs to
            let routeIndex = null;
            allRoutes.forEach((route, index) => {
                if (route.assigned_users.some(u => u.user_id === marker.userData.user_id)) {
                    routeIndex = index;
                }
            });

            if (routeIndex !== null) {
                const color = colorForRoute(routeIndex, allRoutes.length);
                marker.setIcon({
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: color,
                    fillOpacity: 0.8,
                    strokeColor: '#FFFFFF',
                    strokeWeight: 2
                });
            }
        }

        function showNotification(message, type = 'info') {
            const container = document.getElementById('alertsContainer');
            if (!container) return;

            const alertClass = type === 'error' ? 'alert-error' :
                           type === 'warning' ? 'alert-warning' : 'alert-success';
            const icon = type === 'error' ? 'exclamation-circle' :
                     type === 'warning' ? 'exclamation-triangle' : 'check-circle';

            const alertDiv = document.createElement('div');
            alertDiv.className = `alert ${alertClass}`;
            alertDiv.innerHTML = `<i class="fas fa-${icon}"></i> ${message}`;

            // Append, don't overwrite
            container.appendChild(alertDiv);

            // Remove just this alert after 3s
            setTimeout(() => {
                if (alertDiv.parentElement) alertDiv.parentElement.removeChild(alertDiv);
            }, 3000);
        }

        // ============================================================================
        // GOOGLE MAPS API CALLBACK
        // ============================================================================
        // The initMap function is called by the Google Maps API script when it's loaded.

    </script>

    <!-- Turf.js for geometric operations (must load before Google Maps) -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <!-- Google Maps API with visualization library -->
    <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAjESclgKTCpmdmHKc7bzCKIQtYe_vIbb4&libraries=visualization,geometry&callback=initMap"
        defer></script>
</body>

</html>